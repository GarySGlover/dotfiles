#+PROPERTY: header-args :results silent

* Initialisation
This section contains basic configurations for emacs to tidy up the interface and set some defaults for the inbuilt modules that don't fit into other categories.

** Disable package downloads
Remove elpa from the package archives so that no packages will be automtically downloaded. All packages will be installed using the nix package manager.

#+begin_src emacs-lisp :tangle yes
  (setq package-archives nil)
#+end_src

** Cleanup interface
Remove some of the default GUI display components that are typically used with mouse rather than keyboard.

#+begin_src emacs-lisp :tangle yes
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (set-fringe-mode 10)
  (menu-bar-mode -1)
  (setq inhibit-startup-message t)
#+end_src

** Disabled commands
Emacs has disabled some inbuilt functions by default as a safety measure. Replacing the function that is called prior to running these enables all these commands without further confirmation.

#+begin_src emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+end_src

** Use short answers
Allow use of y/n instead of yes/no for interactive command confirmations.

#+begin_src emacs-lisp :tangle yes
  (setq use-short-answers t)
#+end_src

** Clean directories
Tell emacs not to create lock files as everthing being edited is single user so should have no conflicts over files. Use of no-littering to reduce other files being scattered in the filesystem and keep the emacs folder clean.

#+begin_src emacs-lisp :tangle yes
  (use-package no-littering
    :demand t
    :config
    (no-littering-theme-backups))
  (setq create-lockfiles nil)
#+end_src

** Buffer auto revert
Revert the buffer to the on disk file contents when they are changed outside of emacs.

#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
#+end_src

** Environment Variable import
#+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-copy-env "SSH_AGENT_PID")
    (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+end_src

** Tabs are evil
So we disable the horrible things
#+begin_src emacs-lisp :tangle yes
  (setopt indent-tabs-mode nil)
#+end_src

** Mice are evil
Disable mouse inputs in Emacs as everybody knows keyboards are better
#+begin_src emacs-lisp :tangle yes
  (use-package disable-mouse
    :init
    (global-disable-mouse-mode))
#+end_src

** Repeat mode
#+begin_src emacs-lisp :tangle yes
  (setopt repeat-mode t)
#+end_src
* Core Utils
Utilities for emacs that support further parts of the configuration.
** Transient
#+begin_src emacs-lisp :tangle yes
  (use-package transient)
#+end_src
** Posframe
Better popup frames
#+begin_src emacs-lisp :tangle yes
  (use-package posframe)
#+end_src

* Help
** Helpful
#+begin_src emacs-lisp :tangle yes
  (use-package helpful
    :commands
    (helpful-callable
     helpful-command
     helpful-key
     helpful-variable
     helpful-at-point)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key)
    ([remap Info-goto-emacs-command-node] . helpful-function)
    ("C-h M-p" . helpful-at-point))
#+end_src

** Which key
Popup to show available shortcut keys in current mode
#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :demand
    :config
    (which-key-mode)
    (which-key-add-keymap-based-replacements org-mode-map
      "C-c C-v" "Org babel"
      "C-c C-x" "Org extra")
    :bind (:map help-map
                ("C-h" . which-key-C-h-dispatch)
                ("M-w" . which-key-show-top-level)
                ("M-m" . which-key-show-major-movhede))
    :custom
    (which-key-show-early-on-C-h t "Press C-h to show commands")
    (which-key-idle-delay 1 "Delay which key normal display")
    (which-key-idle-secondary-delay 0.05 "Quicker which-key subsequest display")
    (which-key-max-display-columns 3)
    (which-key-show-remaining-keys t))

  (use-package which-key-posframe
    :after (which-key posframe)
    :config
    (defun which-key-posframe--max-dimensions-override (x)
      (cons (min 10 (pop x)) x))
    (advice-add 'which-key-posframe--max-dimensions :filter-return #'which-key-posframe--max-dimensions-override)
    (setq which-key-posframe-poshandler 'posframe-poshandler-frame-top-center)
    (which-key-posframe-mode))
#+end_src
* Visual
** Alert notification
When emacs reports an exception the default action is to play a bell sound. This replaces the sound with a double flash on the modeline background.

#+begin_src emacs-lisp :tangle yes
  (defun double-flash-modeline ()
    (let ((flash-sec (/ 1.0 20)))
      (invert-face 'mode-line)
      (run-with-timer flash-sec nil #'invert-face 'mode-line)
      (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
      (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
  (setq visible-bell nil
        ring-bell-function 'double-flash-modeline)
#+end_src

** Theme
Setup the main theme and fonts used within this emacs configuration.

#+begin_src emacs-lisp :tangle yes
  (set-face-attribute 'default nil
                      :font "FiraCode Nerd Font"
                      :height 100)
  (add-to-list 'default-frame-alist '(font . "FiraCode Nerd Font"))
  (setopt nerd-icons-font-family "FiraCode Nerd Font")

  (load-theme 'doom-dracula t)
#+end_src

Window splitting
#+begin_src emacs-lisp :tangle yes
  (setopt window-divider-mode t)
  (setopt window-divider-default-places t)
  (set-face-foreground 'vertical-border "black")
  (set-face-background 'vertical-border (face-foreground 'vertical-border))
#+end_src
** Transparency
Set default transparency of frames and creation of hydra function for adjusting alpha.

#+begin_src emacs-lisp :tangle yes
  (defun set-frame-alpha (value)
    (set-frame-parameter nil 'alpha-background value))

  (defun get-frame-alpha ()
    (frame-parameter nil 'alpha-background))

  (defun change-frame-alpha-by (value)
    (let ((newAlpha (+ value (get-frame-alpha))))
      (if (> newAlpha (get-frame-alpha))
          (if (> newAlpha 100)
              (set-frame-alpha 100)
            (set-frame-alpha newAlpha))
          (if (< newAlpha 0)
              (set-frame-alpha 0)
            (set-frame-alpha newAlpha)))))
  (set-frame-alpha 85)
  (add-to-list 'default-frame-alist '(alpha-background . 85))

  (transient-define-suffix clover--transient-transparency-increase-frame-alpha ()
    :key "i" :description "Increase"
    (interactive)
    (change-frame-alpha-by 1))
  (transient-define-suffix clover--transient-transparency-decrease-frame-alpha ()
    :key "d" :description "Decrease"
    (interactive)
    (change-frame-alpha-by -1))
  (transient-define-suffix clover--transient-transparency-frame-alpha-low ()
    :key "l" :description "Low"
    (interactive)
    (set-frame-alpha 0))
  (transient-define-suffix clover--transient-transparency-frame-alpha-high ()
    :key "h" :description "High"
    (interactive)
    (set-frame-alpha 100))
  (transient-define-suffix clover--transient-transparency-frame-alpha-reset ()
    :key "r" :description "r"
    (interactive)
    (set-frame-alpha 85))

  (transient-define-prefix ct-transparency ()
    :transient-suffix 'transient--do-stay
    :transient-non-suffix 'transient--do-exit
    [(clover--transient-transparency-increase-frame-alpha)
     (clover--transient-transparency-decrease-frame-alpha)
     (clover--transient-transparency-frame-alpha-low)
     (clover--transient-transparency-frame-alpha-high)
     (clover--transient-transparency-frame-alpha-reset)])
  (bind-key "C-c t" 'ct-transparency)
#+end_src

* Project Management
** Version control

Using Magit as the git porcelain. Is configured to use the same window rather than open a new one for all operations possible. As some operations such as commit open the diff window as well, those buffers open in a seperate window.

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :commands 'magit-status
    :config
    (setq magit-display-buffer-function #'display-buffer)
    :bind ("C-c g" . magit-status))

  (use-package forge
    :after magit)
#+end_src
* Search
** Vertico
#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :init
    (vertico-mode))

  (use-package vertico-posframe
    :init
    (vertico-posframe-mode 1)
    :config
    (setq vertico-posframe-poshandler #'posframe-poshandler-frame-top-center)
  )
#+end_src
** Consult
#+begin_src emacs-lisp :tangle yes
  (use-package consult
    :init
    (define-prefix-command 'consult)
    :bind
    ("C-s" . consult-line)
    ("C-x b" . consult-buffer)
    ("M-y". consult-yank-pop)
    ("C-c s" . consult)
    ("C-c s g" . consult-grep)
    ("C-c s i" . consult-imenu)
    ("C-c s m" . consult-imenu-multi))
#+end_src
** Orderless
#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :config
    (add-to-list 'completion-styles 'orderless)
    :custom
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

* Window  Management
** Window visited order
Store a window parameter in non side windows. This is intended to be used to order windows and find the last visited window for display buffer functions.
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/increment-and-store-window-count (frame)
    "Increment the window counter and store it as a window parameter."
    (let ((selected-win (selected-window)))
      (when (and selected-win
                 (not (window-parameter selected-win 'window-side))
                 (not (window-minibuffer-p selected-win)))
        (with-selected-frame (window-frame selected-win)
          (let ((current-count (or (frame-parameter nil '4lc/window-counter) 0)))
            (setq current-count (+ 1 current-count))
            (set-frame-parameter nil '4lc/window-counter current-count)
            (set-window-parameter selected-win '4lc/window-counter current-count))))))

  (add-hook 'window-selection-change-functions '4lc/increment-and-store-window-count)

  (defun 4lc/get-window-counter ()
    "Get the window counter value from the selected window's parameter."
    (let ((selected-win (selected-window)))
      (when selected-win
        (window-parameter selected-win '4lc/window-counter))))

  (defun 4lc/get-window-with-highest-counter ()
    "Get the window in the current frame with the highest window counter."
    (let ((current-frame (selected-frame))
          (windows (window-list)))
      (cl-reduce
       (lambda (win1 win2)
         (let ((counter1 (window-parameter win1 '4lc/window-counter))
               (counter2 (window-parameter win2 '4lc/window-counter)))
           (if (and counter1 counter2)
               (if (> counter1 counter2) win1 win2)
             (if counter1 win1 win2))))
       windows :initial-value nil)))
#+end_src
** Window resize
Functions to directly set the height and width of windows as either percentage of frame width or character width.
#+begin_src emacs-lisp :tangle yes
    (defun 4lc/set-window-width (val &optional window)
      (window-resize window (- val (window-width window)) t))

    (defun 4lc/window-resize-width (val &optional window)
      (if (< val 1)
          (4lc/set-window-width (truncate (* val (frame-width))) window)
        (4lc/set-window-width val window)))

    (defun 4lc/side-window-width (window &optional side)
      (let ((side (or side (window-parameter window 'window-side))))
        (pcase side
          ('left 4lc/left-side-window-width)
          ('right 4lc/right-side-window-width))))
#+end_src
** Display Buffer rules
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/display-buffer-side-window-width (window &optional side)
    (let ((width (4lc/side-window-width window side)))
      (4lc/window-resize-width width window)))

  (defun display-buffer-maybe-most-recent-window (buffer alist)
    (window--display-buffer buffer (4lc/get-window-with-highest-counter) 'reuse alist))

  (setq 4lc/default-side-window-width 0.2)
  (setq 4lc/left-side-window-width 4lc/default-side-window-width)
  (setq 4lc/right-side-window-width 4lc/default-side-window-width)

  (setq display-buffer-base-action
        '((display-buffer-maybe-most-recent-window
           display-buffer-reuse-window
           display-buffer--maybe-same-window
           display-buffer-in-previous-window
           display-buffer-use-some-window)))

  (setq display-buffer-alist nil)

  (add-to-list 'display-buffer-alist
               '("\\*help\\|\\*info"
                 (display-buffer-in-side-window)
                 (window-width . 4lc/display-buffer-side-window-width)
                 (side . right)
                 (slot . 0)))

  (add-to-list 'display-buffer-alist
               '("magit.*:\\|magit-revision\\|forge:\\|COMMIT_EDITMSG"
                 (display-buffer-in-side-window)
                 (window-width . 4lc/display-buffer-side-window-width)
                 (side . left)
                 (slot . 0)))

  (add-to-list 'display-buffer-alist
               '("magit-diff.*"
                 (display-buffer-in-side-window)
                 (window-width . 4lc/display-buffer-side-window-width)
                 (side . left)
                 (slot . 1)))

  (add-to-list 'display-buffer-alist
               `(,(lambda (buffer-name action) (with-current-buffer buffer-name (derived-mode-p 'dired-mode)))
                 (display-buffer-in-side-window)
                 (window-width . 4lc/display-buffer-side-window-width)
                 (side . left)
                 (slot . 0)))
#+end_src
*** Side Window Size Persistence
When directly resizing a window that is a side window, store the updated size in the value used by the window rules alists for that side.
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/store-side-window-size (DELTA &optional HORIZONTAL)
    (let ((side (window-parameter nil 'window-side)))
      (when side
          (if (and HORIZONTAL (or (string= side 'left) (string= side 'right)))
              (4lc/store--side-window-horizontal-size side)
            (4lc/store--side-window-vertical-size side)))))

  (defun 4lc/store--side-window-horizontal-size (side)
    (if (string= side 'left)
        (setq 4lc/left-side-window-width (window-width))
      (setq 4lc/right-side-window-width (window-width))))

  (defun 4lc/store--side-window-vertical-size (side)
    (if (string= side 'top)
        (setq 4lc/top-side-window-width (window-height))
      (setq 4lc/bottom-side-window-width (window-height))))

  (advice-add 'enlarge-window :after '4lc/store-side-window-size)
  (advice-add 'shrink-window :after '4lc/store-side-window-size)
  
#+end_src
* Editing
** Text mode
#+begin_src emacs-lisp :tangle yes
  (setopt fill-column 100)
  (add-hook 'text-mode-hook #'visual-line-mode)
  (use-package visual-fill-column
    :init
    (setopt visual-fill-column-mode-map (make-sparse-keymap))
    :config
    (setopt visual-fill-column-center-text t)
    :hook
    (visual-line-mode . visual-fill-column-mode))
#+end_src
** Org mode
#+begin_src emacs-lisp :tangle yes
  (use-package org
    :config
    (setopt org-src-window-setup 'plain))
#+end_src
** Visual Tansient
#+begin_src emacs-lisp :tangle yes
  (transient-define-prefix ct-visual-buffer ()
    :transient-suffix 'transient--do-stay
    :transient-non-suffix 'transient--do-exit
    [("c" "Column Indicator" display-fill-column-indicator-mode)
     ("w" "Whitespace" whitespace-mode)])
  (bind-key "C-c v" 'ct-visual-buffer)
#+end_src
** Vertical Ruler
#+begin_src emacs-lisp :tangle yes
  (global-display-fill-column-indicator-mode 1)
  (setopt display-fill-column-indicator-column 100)
  (setopt global-display-fill-column-indicator-mode t)
  (setopt display-fil-lcolumn-indicator-character #xf0689)
#+end_src
* System
** Dired
- Change dired listing mode to not show full details by default.
- Change listing options to hide . & .. and group directories first.
- Add keybind for creating new files.
#+begin_src emacs-lisp :tangle yes
  (use-package dired
    :config
    (setopt dired-listing-switches "-Alh --group-directories-first")
    (setopt dired-hide-details-hide-symlink-targets nil)
    :bind (:map dired-mode-map ("C-+" . dired-create-empty-file))
    :hook (dired-mode . dired-hide-details-mode))
#+end_src

Make Dired find file and create emtpy file aware of subdirectory
#+begin_src emacs-lisp :tangle yes
  (defun dired-subdir-aware (orig-fun &rest args)
    (if (eq major-mode 'dired-mode)
        (let ((default-directory (dired-current-directory)))
          (apply orig-fun args))
      (apply orig-fun args)))

  (advice-add 'find-file-read-args :around 'dired-subdir-aware)
  (advice-add 'read-file-name :around 'dired-subdir-aware)
#+end_src

Dired subtree package for allowing tree style insertion and removal of subdirectories.
#+begin_src emacs-lisp :tangle yes
  (use-package dired-subtree
    :after dired
    :config
    ;; Fix for nerd icons in dired with subtree
    (defun dired-subtree-add-nerd-icons ()
      (interactive)
      (revert-buffer))
    (advice-add 'dired-subtree-toggle :after 'dired-subtree-add-nerd-icons)
    (advice-add 'dired-subtree-cycle :after 'dired-subtree-add-nerd-icons)
    (advice-add 'dired-subtree-remove :after 'dired-subtree-add-nerd-icons)
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)
                ("C-<tab>" . dired-subtree-cycle)
                ("<backtab>" . dired-subtree-remove)))

#+end_src

Dired nerd icons to show icons for files and folders
#+begin_src emacs-lisp :tangle yes
  (use-package nerd-icons-dired
    :after dired
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+end_src
* Programming
** Completion
#+begin_src emacs-lisp :tangle yes
  (use-package corfu
    :init
    (global-corfu-mode)
    :config
    (setopt corfu-popupinfo-mode t)
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (setq-local corfu-auto t) ;; Enable/disable auto completion
        (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                    corfu-popupinfo-delay nil)
        (corfu-mode 1)))
    :hook (minibuffer-setup . corfu-enable-in-minibuffer))
#+end_src
** Eglot
#+begin_src emacs-lisp :tangle yes
  (use-package eglot
    :hook
    (prog-mode . eglot-ensure))
#+end_src
** Treesitter
#+begin_src emacs-lisp :tangle yes
  (customize-set-variable 'treesit-font-lock-level 4)
#+end_src
** Nix
#+begin_src emacs-lisp :tangle (if (string= (getenv "WOLF_LANGUAGE_NIX") "true") "yes" "no")
  (use-package nix-mode
    :mode "\\.nix\\'"
    :hook
    (nix-mode . (lambda ()
                  (setq-local format-all-formatters '(("Nix" alejandra)))))
    (nix-mode . format-all-mode))
#+end_src
** Python
#+begin_src emacs-lisp :tangle yes
  (use-package python
    :init
    (setf (cdr (rassoc 'python-mode auto-mode-alist)) 'python-ts-mode)
    (setf (cdr (rassoc 'python-mode interpreter-mode-alist)) 'python-ts-mode)
      :hook
      (python-ts-mode .
                   (lambda
                     ()
                     (setq-local format-all-formatters
                                 '(("Python" black)))
                     (setq-local python-flymake-command
                                 '("flake8" "-"))
                     (setopt eglot-workspace-configuration
                                   '(:python.\analysis
                                      (:typeCheckingMode "strict")))))
          (python-ts-mode . format-all-mode))
#+end_src
