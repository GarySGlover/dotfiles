#+property: header-args :results silent

* Info
** Key Bindings
*** Global
| Prefix | Name             |
|--------+------------------|
| C-c a  | avy char         |
| C-c b  | beframe          |
| C-c c  | chatgpt-send     |
| C-c d  | >consult         |
| C-c f  | format-all       |
| C-c g  | magit            |
| C-c h  |                  |
| C-c i  |                  |
| C-c j  |                  |
| C-c k  |                  |
| C-c l  |                  |
| C-c n  |                  |
| C-c o  |                  |
| C-c p  | >eat-programs    |
| C-c q  |                  |
| C-c r  |                  |
| C-c s  | git time machine |
| C-c t  | >transparency    |
| C-c u  |                  |
| C-c v  |                  |
| C-c w  |                  |
| C-c x  |                  |
| C-c y  |                  |
| C-c z  |                  |
*** Local
**** Prog mode
| Prefix | Name     |
|--------+----------|
| C-c e  | >eglot   |
| C-c m  | >compile |

** Investigate packages
** Consult eglot
https://github.com/mohkale/consult-eglot
** Hyperbole
** Emacs everywhere
Doesn't work with wayland: https://github.com/tecosaur/emacs-everywhere/issues/50

* Initialisation
This section contains basic configurations for Emacs to tidy up the interface and set some defaults for the inbuilt modules that don't fit into other categories.
** Lexical Binding
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-
#+end_src
** Fix Emacs home
#+begin_src emacs-lisp
 (setq user-emacs-directory (file-truename "~/.config/emacs/"))
#+end_src
** Disable package downloads
Remove elpa from the package archives so that no packages will be automatically downloaded. All packages will be installed using the nix package manager.

#+begin_src emacs-lisp
  (setq package-archives nil)
#+end_src

** Cleanup interface
Remove some of the default GUI display components that are typically used with mouse rather than keyboard.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (set-fringe-mode 10)
  (menu-bar-mode -1)
  (setopt inhibit-startup-message t)
#+end_src

** Disabled commands
Emacs has disabled some inbuilt functions by default as a safety measure. Replacing the function that is called prior to running these enables all these commands without further confirmation.

#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

** Use short answers
Allow use of y/n instead of yes/no for interactive command confirmations.

#+begin_src emacs-lisp
  (setq use-short-answers t)
#+end_src

** Clean directories
Tell Emacs not to create lock files as everything being edited is single user so should have no conflicts over files. Use of no-littering to reduce other files being scattered in the file system and keep the Emacs folder clean.

#+begin_src emacs-lisp
  (use-package no-littering :demand t :config (no-littering-theme-backups))
  (setq create-lockfiles nil)
#+end_src

** Buffer auto revert
Revert the buffer to the on disk file contents when they are changed outside of Emacs.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
  (setq auto-revert-verbose nil)
#+end_src

** Environment Variable import
#+begin_src emacs-lisp
  (use-package
   exec-path-from-shell
   :config
   (exec-path-from-shell-copy-env "SSH_AGENT_PID")
   (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+end_src

** Indentation
Tabs are evil so they are disabled. Indentation defaults to 2.
Dtrt-indent used to guess indentation used in current file and override local setting.
Inhibit electric indent from re-indenting.
#+begin_src emacs-lisp
  (use-package
   dtrt-indent
   :init
   (setopt dtrt-indent-global-mode t)
   (setopt indent-tabs-mode nil)
   (setopt tab-width 2)
   (setopt standard-indent 2)
   ;; (setopt electric-indent-inhibit t)
   )
#+end_src

** Repeat mode
#+begin_src emacs-lisp :lexical t
  (defun repeat-help--which-key-popup ()
    (if-let ((cmd (or this-command real-this-command))
             (keymap
              (or repeat-map (repeat--command-property 'repeat-map))))
      (run-at-time
       0 nil
       (lambda ()
         (which-key--create-buffer-and-show nil (symbol-value keymap))))
      (which-key--hide-popup)))
#+end_src

#+begin_src emacs-lisp
  (use-package
   repeat
   :init (setopt repeat-mode t)

   :config
   ;; Disable the built-in repeat-mode hinting
   (setopt repeat-echo-function #'ignore)

   (advice-add 'repeat-post-hook :after 'repeat-help--which-key-popup))
#+end_src
* Core Utilities
Utilities for Emacs that support further parts of the configuration.
** Direnv
#+begin_src emacs-lisp
  (use-package
   direnv
   :config (setopt direnv-always-show-summary nil)
   :init (direnv-mode))
#+end_src
** GCMH
#+begin_src emacs-lisp
  (use-package gcmh
    :init
    (gcmh-mode 1))
#+end_src

** Transient
#+begin_src emacs-lisp
  (use-package transient)
#+end_src

** Url
#+begin_src emacs-lisp
  (use-package
   url
   :config
   (advice-add 'url-http-create-request :override '4lc/url-http-create-request)
   :init
   (defun 4lc/url-http-create-request ()
     "Create an HTTP request for `url-http-target-url'.
  Use `url-http-referer' as the Referer-header (subject to `url-privacy-level')."
     (let* ((extra-headers)
            (request nil)
            (no-cache
             (cdr-safe (assoc "Pragma" url-http-extra-headers)))
            (using-proxy url-http-proxy)
            (proxy-auth
             (if (or (cdr-safe
                      (assoc
                       "Proxy-Authorization" url-http-extra-headers))
                     (not using-proxy))
                 nil
               (let ((url-basic-auth-storage
                      'url-http-proxy-basic-auth-storage))
                 (url-get-authentication url-http-proxy nil 'any nil))))
            (real-fname (url-filename url-http-target-url))
            (host (url-host url-http-target-url))
            (auth
             (if (cdr-safe
                  (assoc "Authorization" url-http-extra-headers))
                 nil
               (url-get-authentication
                (or (and (boundp 'proxy-info) proxy-info)
                    url-http-target-url)
                nil 'any nil)))
            (ref-url (url-http--encode-string url-http-referer)))
       (if (equal "" real-fname)
           (setq real-fname "/"))
       (setq no-cache (and no-cache (string-match "no-cache" no-cache)))
       (if auth
           (setq auth (concat "Authorization: " auth "\r\n")))
       (if proxy-auth
           (setq proxy-auth
                 (concat "Proxy-Authorization: " proxy-auth "\r\n")))

       ;; Protection against stupid values in the referrer
       (if (and ref-url
                (stringp ref-url)
                (or (string= ref-url "file:nil") (string= ref-url "")))
           (setq ref-url nil))

       ;; url-http-extra-headers contains an assoc-list of
       ;; header/value pairs that we need to put into the request.
       (setq extra-headers
             (mapconcat (lambda (x) (concat (car x) ": " (cdr x)))
                        url-http-extra-headers
                        "\r\n"))
       (if (not (equal extra-headers ""))
           (setq extra-headers (concat extra-headers "\r\n")))

       ;; This was done with a call to `format'.  Concatenating parts has
       ;; the advantage of keeping the parts of each header together and
       ;; allows us to elide null lines directly, at the cost of making
       ;; the layout less clear.
       (setq request
             (concat
              ;; The request
              (or url-http-method "GET") " "
              (url-http--encode-string
               (if (and using-proxy
                        ;; Bug#35969.
                        (not
                         (equal
                          "https" (url-type url-http-target-url))))
                   (let ((url (copy-sequence url-http-target-url)))
                     (setf (url-host url)
                           (puny-encode-domain (url-host url)))
                     (url-recreate-url url))
                 real-fname))
              " HTTP/" url-http-version "\r\n"
              ;; Version of MIME we speak
              "MIME-Version: 1.0\r\n"
              ;; (maybe) Try to keep the connection open
              "Connection: "
              (if (or using-proxy (not url-http-attempt-keepalives))
                  "close"
                "keep-alive")
              "\r\n"
              ;; HTTP extensions we support
              (if url-extensions-header
                  (format "Extension: %s\r\n" url-extensions-header))
              ;; Who we want to talk to
              (unless (assoc "Host" url-http-extra-headers)
                (if (/=
                     (url-port url-http-target-url)
                     (url-scheme-get-property
                      (url-type url-http-target-url) 'default-port))
                    (format "Host: %s:%d\r\n"
                            (url-http--encode-string
                             (puny-encode-domain host))
                            (url-port url-http-target-url))
                  (format "Host: %s\r\n"
                          (url-http--encode-string
                           (puny-encode-domain host)))))
              ;; Who its from
              (if url-personal-mail-address
                  (concat "From: " url-personal-mail-address "\r\n"))
              ;; Encodings we understand
              (if (or url-mime-encoding-string
                      ;; MS-Windows loads zlib dynamically, so recheck
                      ;; in case they made it available since
                      ;; initialization in url-vars.el.
                      (and (eq 'system-type 'windows-nt)
                           (fboundp 'zlib-available-p)
                           (zlib-available-p)
                           (setq url-mime-encoding-string "gzip")))
                  (concat
                   "Accept-encoding: " url-mime-encoding-string "\r\n"))
              (if url-mime-charset-string
                  (concat
                   "Accept-charset: "
                   (url-http--encode-string
                    url-mime-charset-string)
                   "\r\n"))
              ;; Languages we understand
              (if url-mime-language-string
                  (concat
                   "Accept-language: " url-mime-language-string "\r\n"))
              ;; Types we understand
              "Accept: " (or url-mime-accept-string "*/*") "\r\n"
              ;; User agent
              (url-http-user-agent-string)
              ;; Proxy Authorization
              proxy-auth
              ;; Authorization
              auth
              ;; Cookies
              (when (url-use-cookies url-http-target-url)
                (url-http--encode-string
                 (url-cookie-generate-header-lines
                  host
                  real-fname
                  (equal "https" (url-type url-http-target-url)))))
              ;; If-modified-since
              (if (and (not no-cache)
                       (member url-http-method '("GET" nil)))
                  (let ((tm (url-is-cached url-http-target-url)))
                    (if tm
                        (concat
                         "If-modified-since: "
                         (url-get-normalized-date tm)
                         "\r\n"))))
              ;; Whence we came
              (if ref-url
                  (concat "Referer: " ref-url "\r\n"))
              extra-headers
              ;; Length of data
              (if url-http-data
                  (concat
                   "Content-length: "
                   (number-to-string (length url-http-data))
                   "\r\n"))
              ;; End request
              "\r\n"
              ;; Any data
              url-http-data))
       ;; Bug#23750
       (unless (= (string-bytes request) (length request))
         (error "Multibyte text in HTTP request: %s" request))
       (url-http-debug "Request is: \n%s" request)
       request)))
#+end_src

* Help
** Helpful
#+begin_src emacs-lisp
  (use-package
   helpful
   :commands (helpful-callable helpful-command helpful-key helpful-variable helpful-at-point)
   :bind
   ([remap describe-function] . helpful-callable)
   ([remap describe-command] . helpful-command)
   ([remap describe-variable] . helpful-variable)
   ([remap describe-key] . helpful-key)
   ([remap Info-goto-emacs-command-node] . helpful-function)
   ("C-h M-p" . helpful-at-point))
#+end_src

** Which key
Popup to show available shortcut keys in current mode
#+begin_src emacs-lisp
  (use-package
   which-key
   :demand
   :config
   (which-key-mode)
   (which-key-add-keymap-based-replacements org-mode-map "C-c C-v" "Org babel" "C-c C-x" "Org extra")
   :bind
   (:map
    help-map
    ("C-h" . which-key-C-h-dispatch)
    ("M-w" . which-key-show-top-level)
    ("M-m" . which-key-show-major-movhede))
   :custom
   (which-key-show-early-on-C-h t "Press C-h to show commands")
   (which-key-idle-delay 1 "Delay which key normal display")
   (which-key-idle-secondary-delay 0.05 "Quicker which-key subsequest display")
   (which-key-max-display-columns 3)
   (which-key-show-remaining-keys t))
#+end_src

** GPTel
#+begin_src emacs-lisp
  (use-package
   gptel
   :demand t
   :init
   (defun 4lc/set-gptel-directive (&optional language)
     "Set the gptel directive to respond as code for the
  current buffers language "
     (let ((lang (language-id-buffer)))
       (when lang
         (unless (assoc (intern (downcase lang)) gptel-directives)
           (let ((prompt (format "Respond with %s code only" lang)))
             (setq-local gptel-directives
                         (append
                          `((,(intern (downcase lang)) . ,prompt)) gptel-directives))
             (setq-local gptel--system-message prompt))))))

   (defun 4lc/gptel-y-n (f &rest args)
     "Add confirmation to prevent accidental sends"
     (when (yes-or-no-p "Are you sure you want to send to AI?")
       (apply f args)))
   (advice-add 'gptel-curl-get-response :around #'4lc/gptel-y-n)
   (advice-add 'gptel--url-get-response :around #'4lc/gptel-y-n)
   :config (setopt gptel-model "gpt-4-turbo-preview")
   :commands (gptel)
   :bind ("C-c c" . gptel-send)
   :hook ((prog-mode yaml-mode) . 4lc/set-gptel-directive))
#+end_src
* Window  Management
** Window visited order
Store a window parameter in non side windows. This is intended to be used to order windows and find the last visited window for display buffer functions.
#+begin_src emacs-lisp
  (defun 4lc/increment-and-store-window-count (frame)
    "Increment the window counter and store it as a window parameter."
    (let ((selected-win (selected-window)))
      (when (and selected-win
                 (not (window-parameter selected-win 'window-side))
                 (not (window-minibuffer-p selected-win)))
        (with-selected-frame (window-frame selected-win)
          (let ((current-count (or (frame-parameter nil '4lc/window-counter) 0)))
            (setq current-count (+ 1 current-count))
            (set-frame-parameter nil '4lc/window-counter current-count)
            (set-window-parameter selected-win '4lc/window-counter current-count))))))

  (add-hook 'window-selection-change-functions '4lc/increment-and-store-window-count)

  (defun 4lc/get-window-counter ()
    "Get the window counter value from the selected window's parameter."
    (let ((selected-win (selected-window)))
      (when selected-win
        (window-parameter selected-win '4lc/window-counter))))

  (defun 4lc/get-window-with-highest-counter ()
 "Get the window in the current frame with the highest window counter."
    (let ((current-frame (selected-frame))
          (windows (window-list)))
      (cl-reduce
       (lambda (win1 win2)
         (let ((counter1 (window-parameter win1 '4lc/window-counter))
               (counter2 (window-parameter win2 '4lc/window-counter)))
           (if (and counter1 counter2)
               (if (> counter1 counter2)
                   win1
                 win2)
             (if counter1
                 win1
               win2))))
       windows
       :initial-value nil)))
#+end_src
** Window resize
Functions to directly set the height and width of windows as either percentage of frame width or character width.
#+begin_src emacs-lisp
  (defun 4lc/get-window-delta (size)
    (- size (window-height)))

  (defun 4lc/get-window-width-delta (size)
    (- size (window-width)))

  (defun 4lc/set-window-width (val &optional window)
    (window-resize window (- val (window-width window)) t))

  (defun 4lc/window-resize-width (val &optional window)
    (if (< val 1)
        (4lc/set-window-width (truncate (* val (frame-width))) window)
      (4lc/set-window-width val window)))

  (defun 4lc/side-window-width (window &optional side)
    (let ((side (or side (window-parameter window 'window-side))))
      (pcase side
        ('left 4lc/left-side-window-width)
        ('right 4lc/right-side-window-width))))

  (defun 4lc/set-window-height (val &optional window)
    (window-resize window (- val (window-height window))))

  (defun 4lc/window-resize-height (val &optional window)
    (if (< val 1)
        (4lc/set-window-height (truncate (* val (frame-height))) window)
      (4lc/set-window-height val window)))

  (defun 4lc/side-window-height (window &optional side)
    (let ((side (or side (window-parameter window 'window-side))))
      (pcase side
        ('top 4lc/top-side-window-height)
        ('bottom 4lc/bottom-side-window-height))))
#+end_src
** Display Buffer rules
#+begin_src emacs-lisp
  (defun 4lc/display-buffer-side-window-width (window &optional side)
    (let ((width (4lc/side-window-width window side)))
      (4lc/window-resize-width width window)))

  (defun 4lc/display-buffer-side-window-height (window &optional side)
    (let ((height (4lc/side-window-height window side)))
      (4lc/window-resize-height height window)))

  (defun display-buffer-maybe-most-recent-window (buffer alist)
    (unless (cdr (assq 'inhibit-same-window alist))
      (window--display-buffer
       buffer (4lc/get-window-with-highest-counter) 'reuse
       alist)))

  (defun display-buffer-split-current-window (buffer alist)
    (when (window-splittable-p (selected-window) t)
      (window--display-buffer buffer (split-window-sensibly) 'window
                              alist)))

  (defun 4lc/display-buffer-alist-left (title &optional slot)
    (let ((selected-slot
           (if slot
               slot
             0)))
      (add-to-list
       'display-buffer-alist
       `(,title
         (display-buffer-in-side-window)
         (window-width . 0.3)
         (side . left)
         (slot . ,selected-slot)
         (window-parameters
          .
          ((mode-line-format . 'none)
           (no-delete-other-windows . t)))))))

  (defun 4lc/display-buffer-derived-mode-p (mode)
    `(lambda (buffer-name action)
       (with-current-buffer buffer-name
         (derived-mode-p ',mode))))

  (use-package
   window
   :init
   (setq display-buffer-base-action
         '((display-buffer--maybe-same-window
            display-buffer-reuse-window
            display-buffer-maybe-most-recent-window
            display-buffer-in-previous-window
            display-buffer-use-some-window
            display-buffer-split-current-window)))
   (setopt switch-to-buffer-obey-display-actions t)
   (let ((buffer-rules
          `(("^\\*Warnings\\*$" 1)
            ("^\\*Messages\\*$" 1)
            ("^\\*kubel stderr\\*$" 1)
            ("^\\*format-all-errors\\*$" 1)
            ("^\\*kubel-process\\*$" 1)
            ("^\\*Backtrace\\*$" 1)
            ("magit.*" 1)
            "^\\*Woman.*\\*$"
            "^\\*help"
            "^\\*info"
            "^\\*Terraform:"
            "^magit:"
            "^magit-revision"
            "^COMMIT_EDITMSG$"
            "^\\*Embark .*\\*$"
            ,(4lc/display-buffer-derived-mode-p 'dired-mode)
            "^\\*format-all-errors\\*$"
            "^\\*Occur\\*$"
            "^\\*refs.*$")))
     (-each
      buffer-rules
      (lambda (item)
        (if (and (listp item) (not (eq (car item) 'lambda)))
            (apply #'4lc/display-buffer-alist-left item)
          (4lc/display-buffer-alist-left item)))))
   (add-to-list
    'display-buffer-alist '("^\\*scratch+\\*$\\|^\\*GNU Emacs\\*$")))
#+end_src
** Ace window
#+begin_src emacs-lisp
  (use-package ace-window :bind ("M-o" . ace-window))
#+end_src
** Beframe
#+begin_src emacs-lisp
  (use-package
   beframe
   :after consult
   :init
   (beframe-mode 1)
   (defvar consult-buffer-sources)
   (declare-function consult--buffer-state "consult")

   (defface beframe-buffer '((t :inherit font-lock-string-face))
     "Face for `consult' framed buffers.")

   (defun my-beframe-buffer-names-sorted (&optional frame)
     "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
    With optional argument FRAME, return the list of buffers of FRAME."
     (beframe-buffer-names
      frame
      :sort #'beframe-buffer-sort-visibility))

   (defvar beframe-consult-source
     `(:name
       "Frame-specific buffers (current frame)"
       :narrow ?F
       :category buffer
       :face beframe-buffer
       :history beframe-history
       :items ,#'my-beframe-buffer-names-sorted
       :action ,#'switch-to-buffer
       :state ,#'consult--buffer-state))

   (add-to-list 'consult-buffer-sources 'beframe-consult-source)
   :bind-keymap (("C-c b" . beframe-prefix-map)))
#+end_src
* Visual
** Theme
Setup the main theme and fonts used within this emacs configuration.
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "FiraCode Nerd Font-10"))
  (setopt nerd-icons-font-family "FiraCode Nerd Font")

  (use-package
   ef-themes
   :config
   (let* ((ef-allowed-light-themes
           (seq-difference
            ef-themes-light-themes '(ef-cyprus ef-frost ef-light)))
          (light
           (nth
            (random (length ef-allowed-light-themes))
            ef-allowed-light-themes))
          (dark
           (nth
            (random (length ef-themes-dark-themes))
            ef-themes-dark-themes)))
     (setopt ef-themes-to-toggle `(,light ,dark))
     (ef-themes-select dark)))
#+end_src

** Alert notification
When Emacs reports an exception the default action is to play a bell sound. This replaces the sound with a double flash on the mode-line background.

#+begin_src emacs-lisp
  (defun double-flash-modeline ()
    (let ((flash-sec (/ 1.0 20)))
      (invert-face 'mode-line)
      (run-with-timer flash-sec nil #'invert-face 'mode-line)
      (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
      (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
  (setq
   visible-bell nil
   ring-bell-function 'double-flash-modeline)
#+end_src

** Transparency
Set default transparency of frames and creation of hydra function for adjusting alpha.

#+begin_src emacs-lisp
  (defun set-frame-alpha (value)
    (set-frame-parameter nil 'alpha-background value))

  (defun get-frame-alpha ()
    (frame-parameter nil 'alpha-background))

  (defun change-frame-alpha-by (value)
    (let ((newAlpha (+ value (get-frame-alpha))))
      (if (> newAlpha (get-frame-alpha))
          (if (> newAlpha 100)
              (set-frame-alpha 100)
            (set-frame-alpha newAlpha))
        (if (< newAlpha 0)
            (set-frame-alpha 0)
          (set-frame-alpha newAlpha)))))
  (set-frame-alpha 100)
  (add-to-list 'default-frame-alist '(alpha-background . 100))

  (transient-define-suffix
   clover--transient-transparency-increase-frame-alpha
   ()
   :key "i"
   :description
   "Increase"
   (interactive)
   (change-frame-alpha-by 1))
  (transient-define-suffix
  clover--transient-transparency-decrease-frame-alpha
   ()
   :key "d"
   :description
   "Decrease"
   (interactive)
   (change-frame-alpha-by -1))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-low
   ()
   :key "l"
   :description
   "Low"
   (interactive)
   (set-frame-alpha 0))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-high
   ()
   :key "h"
   :description
   "High"
   (interactive)
   (set-frame-alpha 100))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-reset
   ()
   :key "r"
   :description
   "r"
   (interactive)
   (set-frame-alpha 85))

  (transient-define-prefix
   ct-transparency ()
   :transient-suffix 'transient--do-stay
   :transient-non-suffix 'transient--do-exit
   [(clover--transient-transparency-increase-frame-alpha)
    (clover--transient-transparency-decrease-frame-alpha)
    (clover--transient-transparency-frame-alpha-low)
    (clover--transient-transparency-frame-alpha-high)
    (clover--transient-transparency-frame-alpha-reset)])
  (bind-key "C-c t" 'ct-transparency)
#+end_src

** Nerd Icons
For completions windows
#+begin_src emacs-lisp
  (use-package
   nerd-icons-completion
   :after marginalia
   :config
   (nerd-icons-completion-mode)
   (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

** Doom Mode-lines
#+begin_src emacs-lisp
  (use-package doom-modeline :init (doom-modeline-mode 1))
#+end_src
* Project Management
** Project
#+begin_src emacs-lisp
  (use-package project :bind ("C-x p t" . eat-project))
#+end_src
** Version control
Using Magit as the git porcelain. Is configured to use the same window rather than open a new one for all operations possible. As some operations such as commit open the diff window as well, those buffers open in a seperate window.

#+begin_src emacs-lisp
  (use-package
   magit
   :demand t
   :config (setq magit-dispnlay-buffer-function #'display-buffer)
   (advice-add
    'magit-worktree-delete
    :after (lambda (&optional WORKTREE) (project-forget-zombie-projects)))
   :bind (("C-c g" . magit-status) ("C-x p m" . magit-project-status)))
#+end_src

Easy look through files git history
#+begin_src emacs-lisp
  (use-package git-timemachine
    :bind ("C-c s" . git-timemachine))
#+end_src
* Navigation
** Avy
#+begin_src emacs-lisp
  (use-package
   avy
   :config (setopt avy-timeout-seconds 0.2)

   (setf
    (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
    (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line
    (alist-get ?l avy-dispatch-alist) 'avy-action-teleport
    (alist-get ?m avy-dispatch-alist) 'avy-action-mark
    (alist-get ?w avy-dispatch-alist) 'avy-action-copy
    (alist-get ?x avy-dispatch-alist) 'avy-action-kill-move
    (alist-get ?y avy-dispatch-alist) 'avy-action-yank
    (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-line
    (alist-get ?z avy-dispatch-alist) 'avy-action-zap-to-char)
   (setopt avy-keys '(?i ?s ?r ?t ?n ?e ?a ?o))
   (-each
    avy-keys
    (lambda (x) (setq avy-dispatch-alist (delq (assoc x avy-dispatch-alist) avy-dispatch-alist))))

   :bind ("C-c a" . avy-goto-char-timer))

  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window (cdr (ring-ref avy-ring 0))))
#+end_src
** Consult
#+begin_src emacs-lisp
  (use-package
   consult
   :init (setopt enable-recursive-minibuffers t)
   (setq
    xref-show-xrefs-function #'consult-xref
    xref-show-definitions-function #'consult-xref)
   :bind
   ( ;; C-c bindings in `mode-specific-map'
    ("C-c M-x" . consult-mode-command)
    ("C-c d h" . consult-history)
    ("C-c d k" . consult-kmacro)
    ("C-c d m" . consult-man)
    ("C-c d i" . consult-info)
    ([remap Info-search] . consult-info)
    ;; C-x bindings in `ctl-x-map'
    ("C-x M-:" . consult-complex-command) ;; orig. repeat-complex-command
    ("C-x b" . consult-buffer) ;; orig. switch-to-buffer
    ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
    ("C-x 5 b" . consult-buffer-other-frame) ;; orig. switch-to-buffer-other-frame
    ("C-x t b" . consult-buffer-other-tab) ;; orig. switch-to-buffer-other-tab
    ("C-x r b" . consult-bookmark) ;; orig. bookmark-jump
    ("C-x p b" . consult-project-buffer) ;; orig. project-switch-to-buffer
    ;; Custom M-# bindings for fast register access
    ("M-#" . consult-register-load)
    ("M-'" . consult-register-store) ;; orig. abbrev-prefix-mark (unrelated)
    ("C-M-#" . consult-register)
    ;; Other custom bindings
    ("M-y" . consult-yank-pop) ;; orig. yank-pop
    ;; M-g bindings in `goto-map'
    ("M-g e" . consult-compile-error)
    ("M-g f" . consult-flymake)
    ("M-g g" . consult-goto-line) ;; orig. goto-line
    ("M-g M-g" . consult-goto-line) ;; orig. goto-line
    ("M-g o" . consult-outline) ;; Alternative: consult-org-heading
    ("M-g m" . consult-mark)
    ("M-g k" . consult-global-mark)
    ("M-g s" . consult-flyspell)
    ("M-g i" . consult-imenu)
    ("M-g I" . consult-imenu-multi)
    ("M-g y" . consult-yasnippet)
    ;; M-s bindings in `search-map'
    ("M-s d" . consult-find) ;; Alternative: consult-fd
    ("M-s g" . consult-grep)
    ("M-s G" . consult-git-grep)
    ("M-s r" . consult-ripgrep)
    ("M-s l" . consult-line)
    ("M-s L" . consult-line-multi)
    ("M-s k" . consult-keep-lines)
    ("M-s u" . consult-focus-lines)
    ;; Isearch integration
    ("M-s e" . consult-isearch-history)
    :map
    isearch-mode-map
    ("M-e" . consult-isearch-history) ;; orig. isearch-edit-string
    ("M-s e" . consult-isearch-history) ;; orig. isearch-edit-string
    ("M-s l" . consult-line) ;; needed by consult-line to detect isearch
    ("M-s L" . consult-line-multi) ;; needed by consult-line to detect isearch
    ;; Minibuffer history
    :map
    minibuffer-local-map
    ("M-s" . consult-history) ;; orig. next-matching-history-element
    ("M-r" . consult-history)))
#+end_src
** Embark
#+begin_src emacs-lisp
  (use-package
   embark
   :bind
   (("C-." . embark-act)
    ("C-;" . embark-dwim)
    ("C-h B" . embark-bindings)
    :map
    embark-identifier-map
    ("RET" . xref-find-definitions-other-window))
   :init (setq prefix-help-command #'embark-prefix-help-command))

  (use-package
   embark-consult
   :after (embark consult)
   :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

Which-key for Embark
#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets)
                       "…"
                     "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding) (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator embark-highlight-indicator embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter :around #'embark-hide-which-key-indicator)
#+end_src
** Margnalia
#+begin_src emacs-lisp
  (use-package
   marginalia
   :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
   :init (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp
  (use-package
   orderless
   :config (add-to-list 'completion-styles 'orderless)
   :custom
   (completion-category-defaults nil)
   (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Vertico
#+begin_src emacs-lisp
  (use-package vertico :init (vertico-mode) :bind (:map vertico-map ("M-s" . vertico-suspend)))
#+end_src
* Editing
** Column Indicator
#+begin_src emacs-lisp
  (use-package
   visual-fill-column
   :config
   (setopt display-fill-column-indicator-column 100)
   (setopt display-fil-lcolumn-indicator-character #xf0689)
   (setopt fill-column 100)
   (setopt visual-fill-column-center-text nil)
   (setopt visual-line-fringe-indicators '(left-curly-arrow nil))
   :hook
   (visual-line-mode . visual-fill-column-mode)
   (text-mode-hook . (lambda () (visual-line-mode t))))
#+end_src
** Eglot breadcrumbs
#+begin_src emacs-lisp
  (use-package breadcrumb :init (breadcrumb-mode 1))
#+end_src
** Format all
#+begin_src emacs-lisp
  (use-package
   format-all
   :commands (format-all-mode define-format-all-formatter)
   :bind (:map prog-mode-map ("C-c f" . format-all-region-or-buffer))
   :hook
   (prog-mode . format-all-mode)
   (yaml-ts-mode . format-all-mode))
#+end_src
** Highlight current line
#+begin_src emacs-lisp
  (use-package
    hl-line
    :init
    (setopt global-hl-line-sticky-flag nil)
    (setopt hl-line-sticky-flag nil)
    (global-hl-line-mode t))
#+end_src
** Highlight indentation
Indent bars
#+begin_src emacs-lisp
  (use-package
    indent-bars
    :demand t
    :config
    (setopt indent-bars-pattern ".")
    (setopt indent-bars-width-frac 0.1)
    (setopt indent-bars-highlight-current-depth '(:pattern "." :width 0.40))
    (setopt indent-bars-treesit-support t)
    (setopt indent-bars-no-descend-string t)
    (setopt indent-bars-spacing-override nil)
    :hook ((prog-mode yaml-ts-mode) . indent-bars-mode))
#+end_src

** Line numbers
#+begin_src emacs-lisp
  (use-package simple
    :init
    (setopt display-line-numbers-type 'relative)
    :hook
    (prog-mode . display-line-numbers-mode)
    (yaml-mode . display-line-numbers-mode))
#+end_src
** Macros
#+begin_src emacs-lisp
  (defalias 'convert-devops-yaml-parameter-to-full
     (kmacro "a i - SPC n a m e : <escape> s : <return> <backspace> <return> i SPC SPC t y p e : SPC s t r i n g <return> d e f a u l t : SPC <escape> n a"))
#+end_src
** Org mode
#+begin_src emacs-lisp
  (use-package
   org
   :init
   (defun 4lc/org-babel-add-language (lang)
     (org-babel-do-load-languages
      'org-babel-load-languages
      (add-to-list 'org-babel-load-languages `(,lang . t))))
   :config
   (setopt org-src-window-setup 'plain)
   (setopt org-startup-indented t)
   (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Replace region
#+begin_src emacs-lisp
  (delete-selection-mode t)

  (defun 4lc/yank-replace (&optional ARG)
    (if (and (region-active-p) (bound-and-true-p delete-selection-mode))
        (delete-active-region)))

  (advice-add 'yank :before #'4lc/yank-replace)
#+end_src
** Spelling
#+begin_src emacs-lisp
  (use-package
   flyspell
   :config
   (setopt ispell-list-command "--list")
   (setopt ispell-program-name "aspell")
   :bind (:map flyspell-mode-map ("C-." . nil))
   :init
   (defun flyspell-on-for-buffer-type ()
     "Enable Flyspell appropriately for the major mode of the current buffer.  Uses `flyspell-prog-mode' for modes derived from `prog-mode', so only strings and comments get checked.  All other buffers get `flyspell-mode' to check all text.  If flyspell is already enabled, does nothing."
     (interactive)
     (if (not (symbol-value flyspell-mode)) ; if not already on
         (progn
           (if (derived-mode-p 'prog-mode)
               (progn
                 (message "Flyspell on (code)")
                 (flyspell-prog-mode))
             ;; else
             (progn
               (message "Flyspell on (text)")
               (flyspell-mode 1)))
           ;; I tried putting (flyspell-buffer) here but it didn't seem to work
           )))
   (defun flyspell-toggle ()
     "Turn Flyspell on if it is off, or off if it is on.  When turning on, it uses `flyspell-on-for-buffer-type' so code-vs-text is handled appropriately."
     (interactive)
     (if (symbol-value flyspell-mode)
         (progn ; flyspell is on, turn it off
           (message "Flyspell off")
           (flyspell-mode -1))
       ; else - flyspell is off, turn it on
       (flyspell-on-for-buffer-type)))
   :hook ((find-file prog-mode text-mode) . flyspell-on-for-buffer-type))
#+end_src
** Trailing white-space
#+begin_src emacs-lisp
  (use-package
   whitespace
   :config
   (setopt
    whitespace-style
    '(face trailing empty missing-newline-at-eof))
   :hook (prog-mode . whitespace-mode)
   (whitespace-mode
    .
    (lambda ()
      (if whitespace-mode
          (add-hook 'before-save-hook 'whitespace-cleanup nil 'local)
        (remove-hook 'before-save-hook 'whitespace-cleanup 'local)))))
#+end_src

* System
** Dired
- Change dired listing mode to not show full details by default.
- Change listing options to hide . & .. and group directories first.
- Add key-bind for creating new files.
#+begin_src emacs-lisp
  (use-package
   dired
   :config
   (setopt dired-listing-switches "-Alh --group-directories-first")
   (setopt dired-hide-details-hide-symlink-targets nil)
 :bind (:map dired-mode-map ("C-+" . dired-create-empty-file))
   :hook (dired-mode . dired-hide-details-mode))
#+end_src

Dired nerd icons to show icons for files and folders
#+begin_src emacs-lisp
  (use-package nerd-icons-dired :after dired :hook (dired-mode . nerd-icons-dired-mode))
#+end_src
** Kubernetes
#+begin_src emacs-lisp
  (use-package
   kubel
   :commands kubel
   :config
   (defun kubel-delete-resource-confirmation ()
     (interactive)
     (y-or-n-p "Are you sure you want to delete resource?"))
   (advice-add
    'kubel-delete-resource
    :before-while #'kubel-delete-resource-confirmation)

   (defun kubel-quick-edit ()
     "Quickly edit any resource."
     (interactive)
     (kubel--describe-resource
      (completing-read
       "Select resource: " (kubel--kubernetes-resources-list)))))
#+end_src
** Eat
#+begin_src emacs-lisp
  (use-package
   eat
   :init
   (defun 4lc/eat-program (name)
     (interactive)
     (let ((eat-buffer-name (format "*%s*" name))
           (eat-kill-buffer-on-exit t))
       (eat name)))
   :bind
   (("C-c p b" .
     (lambda ()
       (interactive)
       (4lc/eat-program "btop")))
    ("C-c p k" .
     (lambda ()
       (interactive)
       (4lc/eat-program "k9s")))
    ("C-c p f" .
     (lambda ()
       (interactive)
       (4lc/eat-program "fish")))
    ("C-c p s" .
     (lambda ()
       (interactive)
       (4lc/eat-program "bash")))))
#+end_src
* Languages
** Bash
#+begin_src emacs-lisp
  (use-package
   sh-script
   :init
   (add-to-list 'major-mode-remap-alist (cons 'sh-mode 'bash-ts-mode))
   :config (setopt sh-basic-offset 2)
   :hook
   (bash-ts-mode
    .
    (lambda ()
      (setq-local
       format-all-formatters '(("Shell" (shfmt "-i" "2" "-ci")))))))
#+end_src
** CMake
#+begin_src emacs-lisp
  (use-package cmake-ts-mode)
#+end_src
** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode)
#+end_src
** Emacs Lisp
#+begin_src emacs-lisp
  (define-format-all-formatter
   elisp-autofmt
   (:executable)
   (:install)
   (:languages "Emacs Lisp")
   (:features region)
   (:format
    (format-all--buffer-native
     'elisp-autofmt-mode
     (if region
         (lambda () (elisp-autofmt-region (car region) (cdr region)))
       (lambda () (elisp-autofmt-region (point-min) (point-max)))))))

  (use-package
   elisp-mode
   :hook
   (emacs-lisp-mode
    .
    (lambda ()
      (setq-local format-all-formatters
                  '(("Emacs Lisp" elisp-autofmt))))))
#+end_src
** Go
#+begin_src emacs-lisp
  (use-package
   go-ts-mode
   :mode ("\\.go\\'" . go-ts-mode) ("/go\\.mod\\'" . go-mod-ts-mode))
#+end_src
** Markdown
#+begin_src emacs-lisp
  (use-package
   markdown-mode
   :defer t)
#+end_src
** Nim
#+begin_src emacs-lisp
  (use-package
   nim-ts-mode
   :init
   (define-format-all-formatter
    nph
    (:executable "nph")
    (:install)
    (:languages "nim")
    (:features)
    (:format (format-all--buffer-easy executable "-")))
   (setopt nim-ts-mode--font-base-theme (car custom-enabled-themes))
   :defer t
   :config
   (add-to-list
    'eglot-server-programs '(nim-ts-mode . ("nimlangserver")))
   :hook
   (nim-ts-mode
    . (lambda () (setq-local format-all-formatters '(("nim" nph))))))

  (defun flymake-diag-region-drop-col (fun buffer line &optional col)
    (message "Running clover flymake diag")
    (apply fun buffer line))

  (advice-add
   'flymake-diag-region
   :around #'flymake-diag-region-drop-col)
  (advice-remove 'flymake-diag-region #'flymake-diag-region-drop-col)
#+end_src

** Nix
  #+begin_src emacs-lisp
    (use-package
     nix-ts-mode
     :defer t
     :mode "\\.nix\\'"
     :config (add-to-list 'eglot-server-programs '(nix-ts-mode . ("rnix-lsp")))
     :hook (nix-ts-mode . (lambda () (setq-local format-all-formatters '(("Nix" alejandra))))))
#+end_src
** Python
#+begin_src emacs-lisp
  (use-package
   python
   :defer t
   :init
   (setf (cdr (rassoc 'python-mode auto-mode-alist)) 'python-ts-mode)
   (setf (cdr (rassoc 'python-mode interpreter-mode-alist)) 'python-ts-mode)
   :hook
   (python-ts-mode
    .
    (lambda ()
      (setq-local format-all-formatters '(("Python" black)))
      (setq-local python-flymake-command '("flake8" "-"))
      (setopt eglot-workspace-configuration '(:python.\analysis (:typeCheckingMode "strict"))))))
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rust-ts-mode :mode "\\.rs\\'")
#+end_src
** Terraform
#+begin_src emacs-lisp
  (use-package
   terraform-mode
   :defer t
   :bind ("C-c C-d C-d" . terraform-doc)
   :config (add-to-list 'eglot-server-programs '(terraform-mode . ("terraform-ls" "serve"))))
#+end_src
** Toml
#+begin_src emacs-lisp
  (use-package
   toml-ts-mode
   :init
   (add-to-list
    'major-mode-remap-alist (cons 'conf-toml-mode 'toml-ts-mode)))
#+end_src
** Typescript
#+begin_src emacs-lisp
  (use-package typescript-ts-mode)
#+end_src
** Yaml
#+begin_src emacs-lisp
  (define-format-all-formatter
   yamlfmt
   (:executable "yamlfmt")
   (:install)
   (:languages "YAML")
   (:features)
   (:format
    (if (project-current)
        (format-all--buffer-easy
         executable "-conf"
         (expand-file-name
          (s-concat (project-root (project-current)) ".yamlfmt"))
         "-")
      (format-all--buffer-easy executable "-"))))

  (use-package
   yaml-ts-mode
   :defer t
   :hook
   (yaml-ts-mode
    .
    (lambda () (setq-local format-all-formatters '(("YAML" yamlfmt))))))

  (use-package
   yaml-pro
   :hook (yaml-ts-mode . yaml-pro-ts-mode)
   :bind
   (:map
    yaml-pro-ts-mode
    ("M-<up>" . yaml-pro-ts-move-subtree-up)
    ("M-<down>" . yaml-pro-ts-move-subtree-down))
   (:repeat-map
    my/yaml-pro/tree-repeat-map
    ("n" . yaml-pro-ts-next-subtree)
    ("p" . yaml-pro-ts-prev-subtree)
    ("u" . yaml-pro-ts-up-level)
    ("d" . yaml-pro-ts-down-level)
    ("m" . yaml-pro-ts-mark-subtree)
    ("k" . yaml-pro-ts-kill-subtree)
    ("a" . yaml-pro-ts-first-sibling)
    ("e" . yaml-pro-ts-last-sibling)
    ("SPC" . my/yaml-pro/set-mark)))
#+end_src

#+begin_src emacs-lisp
  (use-package
   restclient
   :hook
   (restclient-mode . restclient-test-mode)
   (restclient-test-mode . flymake-mode))
#+end_src
** Verb
#+begin_src emacs-lisp
  (use-package verb :init (4lc/org-babel-add-language 'verb))
#+end_src
* Programming
** Compilation
#+begin_src emacs-lisp
  (use-package compile
    :init
    (defun compile-comint ()
      (interactive)
      (compile (eval compile-command) t))
    :bind (:map prog-mode-map
                ("C-c m c" . compile)
                ("C-c m r" . recompile)
                ("C-c m i" . compile-comint)))
#+end_src
** Completion
#+begin_src emacs-lisp
  (use-package
   corfu
   :init (setopt global-corfu-mode t)
   :config
   (setopt corfu-auto t)
   (setopt corfu-popupinfo-mode t)
   (setopt corfu-popupinfo-delay '(0.5 . 0.5))
   (defun corfu-enable-in-minibuffer ()
     "Enable Corfu in the minibuffer if `completion-at-point' is bound."
     (when (where-is-internal #'completion-at-point (list (current-local-map)))
       (setq-local corfu-auto t) ;; Enable/disable auto completion
       (setq-local
        corfu-echo-delay nil ;; Disable automatic echo and popup
        corfu-popupinfo-delay nil)
       (corfu-mode 1)))
   :hook (minibuffer-setup . corfu-enable-in-minibuffer))
#+end_src
** Language ID
#+begin_src emacs-lisp
  (use-package
   language-id
   :config
   (setopt
    language-id--definitions
    (append
     '(("Nix" nix-ts-mode) ("nim" nim-mode)) language-id--definitions)))
#+end_src
** LSP
Configuration for LSP support in prog-mode and yaml-ts-mode. Using Emacs inbuilt mode Eglot.
Config options to reduce the logging and improve the performance.
#+begin_src emacs-lisp
  (use-package
   eglot
   :hook ((prog-mode yaml-ts-mode) . eglot-ensure)
   :bind
   (:map
    eglot-mode-map
    ("C-c e r" . eglot-rename)
    ("C-c e f" . eglot-format)
    ("C-c e a" . eglot-code-actions)
    ("C-c e o" . eglot-code-action-organize-imports)
    ("C-c e i" . eglot-code-action-inline)
    ("C-c e x" . eglot-code-action-extract)
    ("C-c e w" . eglot-code-action-rewrite)
    ("C-c e q" . eglot-code-action-quickfix)
    ("C-c e h" . eldoc))
   :config
   (fset #'jsonrpc--log-event #'ignore)
   (setopt eglot-events-buffer-size 0))
#+end_src
** Treesitter
#+begin_src emacs-lisp
  (use-package
   treesit
   :init
   (defun 4lc/treesitter-major-mode-remap ()
     "Remap major modes to their treesitter counterparts if available."
     (interactive)
     ;; Iterate over all loaded packages and find "-ts-mode" ones
     (dolist (mode (apropos-internal "-ts-mode$" 'functionp))
       (let*
           ((ts-mode-name (symbol-name mode)) ; Convert symbol to string
            (normal-mode-name
             (replace-regexp-in-string
              "-ts-mode$" "-mode" ts-mode-name))
            (normal-mode-symbol (intern-soft normal-mode-name)))
         (when (and normal-mode-symbol (fboundp normal-mode-symbol))
           (progn
             (add-to-list
              'major-mode-remap-alist
              (cons normal-mode-symbol mode)))))))

   (defvar 4lc/treesitter-no-auto-mode ()
     "List of Treesitter modes that are not auto-remapped.")

   (defun 4lc/update-treesitter-no-auto-mode-list ()
     "Update `4lc/treesitter-no-auto-mode' with Treesitter modes not in `major-mode-remap-alist'."
     (setq 4lc/treesitter-no-auto-mode nil)
     (let ((ts-modes
            (seq-filter
             (lambda (mode)
               (string-suffix-p "-ts-mode" (symbol-name mode)))
             (apropos-internal "-ts-mode" 'commandp)))
           (remapped-modes (mapcar 'cdr major-mode-remap-alist))
           (auto-modes (mapcar 'cdr auto-mode-alist)))
       (dolist (mode ts-modes)
         (unless (or (memq mode remapped-modes) (memq mode auto-modes))
           (add-to-list '4lc/treesitter-no-auto-mode mode)))))

   (4lc/treesitter-major-mode-remap)
   (4lc/update-treesitter-no-auto-mode-list)

   :config (setopt treesit-font-lock-level 4)
   :custom
   (setopt
    treesit-extra-load-path '("~/.config/emacs/var/tree-sitter")))
#+end_src
