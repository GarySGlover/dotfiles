#+title: My Emacs Config
#+author: Gary Glover
#+property: header-args :results silent
#+STARTUP: content

* Core Emacs
** Lexical Binding
Configure lexical binding for the rest of this init. A lexically-bound variable
has lexical scope, meaning that any reference to the variable must be
located textually within the binding construct.

This must be kept as the first entry in this list as documented in
"(elisp)Using Lexical Binding".

#+begin_src emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+end_src

** Byte compiler warnings
Silence the byte compiler warnings but still log. This is to prevent
Emaccs always displaying the \ast{}Warnings\ast{} buffer on startup.

#+begin_src emacs-lisp :tangle yes
  (use-package
   comp
   :custom native-comp-async-report-warnings-errors 'silent)
#+end_src

** Disable package downloads
Remove elpa from the package archives so that no packages will be
automatically downloaded. All packages will be installed using the nix
package manager.

#+begin_src emacs-lisp :tangle yes
  (use-package package
    :custom
    (package-archives nil "Remove all package download locations"))
#+end_src

* Key Bindings
** Meow
This is the meow modal editing suite.
#+begin_src emacs-lisp :tangle yes
  (use-package
   meow
   :init (meow-global-mode 1)
   :config
   (setopt
    meow-cheatsheet-layout meow-cheatsheet-layout-qwerty
    meow-use-clipboard t)
   ;; Set keys for MOTION state. This is the state used in read-only style buffers like dired/help/magit
   (meow-motion-overwrite-define-key
    '("h" . meow-left)
    '("j" . meow-next)
    '("k" . meow-prev)
    '("l" . meow-right)
    '("<escape>" . ignore))
   (meow-leader-define-key
    ;; Allow SPC h/j/k/l to run the original command that will be bound to H-<h/j/k/l>
    '("h" . "H-h")
    '("j" . "H-j")
    '("k" . "H-k")
    '("l" . "H-l")
    ;; Use SPC (0-9) for digit arguments.
    '("1" . meow-digit-argument)
    '("2" . meow-digit-argument)
    '("3" . meow-digit-argument)
    '("4" . meow-digit-argument)
    '("5" . meow-digit-argument)
    '("6" . meow-digit-argument)
    '("7" . meow-digit-argument)
    '("8" . meow-digit-argument)
    '("9" . meow-digit-argument)
    '("0" . meow-digit-argument)
    ;; Use SPC //? for accessing meow help
    '("/" . meow-keypad-describe-key)
    '("?" . meow-cheatsheet))
   (meow-normal-define-key
    '("0" . meow-expand-0)
    '("9" . meow-expand-9)
    '("8" . meow-expand-8)
    '("7" . meow-expand-7)
    '("6" . meow-expand-6)
    '("5" . meow-expand-5)
    '("4" . meow-expand-4)
    '("3" . meow-expand-3)
    '("2" . meow-expand-2)
    '("1" . meow-expand-1)
    '("-" . negative-argument)
    '(";" . meow-reverse)
    '("," . meow-inner-of-thing)
    '("." . meow-bounds-of-thing)
    '("[" . meow-beginning-of-thing)
    '("]" . meow-end-of-thing)
    '("a" . meow-append)
    '("A" . meow-open-below)
    '("b" . meow-back-word)
    '("B" . meow-back-symbol)
    '("c" . meow-change)
    '("d" . meow-delete)
    '("D" . meow-backward-delete)
    '("e" . meow-next-word)
    '("E" . meow-next-symbol)
    '("f" . meow-find)
    '("g" . meow-cancel-selection)
    '("G" . meow-grab)
    '("h" . meow-left)
    '("H" . meow-left-expand)
    '("i" . meow-insert)
    '("I" . meow-open-above)
    '("j" . meow-next)
    '("J" . meow-next-expand)
    '("k" . meow-prev)
    '("K" . meow-prev-expand)
    '("l" . meow-right)
    '("L" . meow-right-expand)
    '("m" . meow-join)
    '("n" . meow-search)
    '("o" . meow-block)
    '("O" . meow-to-block)
    '("p" . meow-yank)
    '("q" . meow-quit)
    '("Q" . meow-goto-line)
    '("r" . meow-replace)
    '("R" . meow-swap-grab)
    '("s" . meow-kill)
    '("t" . meow-till)
    '("u" . meow-undo)
    '("U" . meow-undo-in-selection)
    '("v" . meow-visit)
    '("w" . meow-mark-word)
    '("W" . meow-mark-symbol)
    '("x" . meow-line)
    '("X" . meow-goto-line)
    '("y" . meow-save)
    '("Y" . meow-sync-grab)
    '("z" . meow-pop-selection)
    '("'" . repeat)
    '("<escape>" . ignore)))
#+end_src
** General
#+begin_src emacs-lisp :tangle yes
  (use-package general
    :init
    (general-define-key
     :keymaps 'global-map
     "<f5>" #'standard-themes-toggle
     "M-S" #'vertico-suspend)
    (with-eval-after-load 'corfu-candidate-overlay
      (general-define-key
       :keymaps 'corfu-candidate-overlay-completion-map
       "C-n" #'completion-at-point
       "<tab>" #'corfu-candidate-overlay-complete-at-point)))
#+end_src
** TODO Hydra
** TODO Transient

* UI Enhancements
** Basic display changes
#+begin_src emacs-lisp :tangle yes
  (setopt
   scroll-bar-mode nil
   tool-bar-mode nil
   menu-bar-mode nil)
#+end_src
** Theme
#+begin_src emacs-lisp :tangle yes
  (use-package standard-themes
    :init
    (standard-themes-load-dark)
    :custom
    (standard-themes-bold-constructs t)
    (standard-themes-italic-constructs t)
    (standard-themes-mixed-fonts t)
    (standard-themes-variable-pitch-ui t)
    (standard-themes-prompts '(extrabold italic)))
#+end_src
** Vertico
Vertico provides a minimalistic vertical completion interface for
Emacs, making it easier to navigate and select from a list of
candidates. It is efficient, supports cycling through options, and
integrates well with other packages like Consult and Marginalia.
#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :commands (vertico-mode vertico-suspend)
    :init (vertico-mode)
    :config
    (setopt
     enable-recursive-minibuffers t
     vertico-cycle t))
#+end_src
*** Multiform
Allows for the setting of different display forms for Vertico for
individual commmands or categories
#+begin_src emacs-lisp :tangle yes
  (use-package vertico-multiform
    :after vertico
    :commands (vertico-multiform-mode)
    :init (vertico-multiform-mode)
    :config
    (setopt vertico-multiform-commands
	    '((consult-line buffer)))
    (setopt vertico-multiform-categories
	    '((consult-grep buffer))))
#+end_src
** Orderless
#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :config
    (setopt
     completion-styles '(orderless basic)
     completion-category-defaults nil
     completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Corfu
Corfu is an extension for complete at point that dissplays in a popup
instead of in the minibuffer. This is similar to intellisense in other
editors.
#+begin_src emacs-lisp :tangle yes
  (use-package corfu
    :config
    (setopt
     corfu-auto t
     corfu-cycle t)
    :bind (:map corfu-map
                ("RET" . nil))
    :init (setopt global-corfu-mode t))
#+end_src
*** Overlay
#+begin_src emacs-lisp :tangle no
  (use-package corfu-candidate-overlay
    :after corfu
    :init
    (setq corfu-candidate-overlay-completion-map
	  (make-sparse-keymap))
    :config
    (corfu-candidate-overlay-mode +1)
    (defun corfu-candidate-overlay-completion-map--enable
	(position prefix candidate how-many-candidates)
      (unless
	  (= 0
	     (length candidate))
	(set-transient-map corfu-candidate-overlay-completion-map)))
    (advice-add 'corfu-candidate-overlay--update :after #'corfu-candidate-overlay-completion-map--enable))
#+end_src
*** Popup Info
Extension for Corfu that displays the information for a completion
candidate in a popup.
#+begin_src emacs-lisp :tangle yes
  (use-package corfu-popupinfo
    :after corfu
    :hook (global-corfu-mode . corfu-popupinfo-mode))
#+end_src
** TODO Consult
** TODO Eglot
Will need to update Corfu for Eglot
** TODO Indent Bars
** TODO Rainbow delimaters
** Keycast
Display the keys pressed and the associated command in the header line.
#+begin_src emacs-lisp :tangle yes
  (use-package keycast
    :commands  (keycast-header-line-mode)
    :init (keycast-header-line-mode))
#+end_src
** TODO [#A] Mode Line
#+begin_src emacs-lisp :tangle no
  (defun clover-mode-line-buffer ()
    (let ((face (cond
                 ((and (buffer-file-name) (buffer-modified-p)) 'error)
                 ((buffer-file-name) 'success)
                 (t 'warning))))
      (format "%s" (propertize (buffer-name) 'face face))))

  (setq-default mode-line-format
                '(:eval (clover-mode-line-buffer)
                        ))
#+end_src
* Information Management
** TODO Hyperbole
#+begin_src emacs-lisp :tangle yes
  (use-package hyperbole
    :init (hyperbole-mode 1))
#+end_src

** TODO Org Mode
#+begin_src emacs-lisp :tangle yes
  (use-package org
    :config
    (setopt
     org-pretty-entities t
     org-startup-indented t))
#+end_src
*** Org Modern
Styling package for org mode buffers.
#+begin_src emacs-lisp :tangle yes
  (use-package org-modern
    :hook (org-mode . org-modern-mode))
#+end_src
*** Org Modern Indent
#+begin_src emacs-lisp :tangle yes
  (use-package org-modern-indent
    :hook (org-mode . org-modern-indent-mode))
#+end_src

** TODO Denote
* Editing Enhancements
** Yasnippets
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :init (yas-global-mode 1))
#+end_src

*** Yasnippets CAPF
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-capf)
#+end_src
** Indent
*** Aggressive Indent
Keep running the indentation as typing occurs instead of only on
newlines.
#+begin_src emacs-lisp :tangle yes
  (use-package aggressive-indent
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src
** TODO GPTel
** TODO Codeium
** TODO Format All
** TODO Treesitter
** TODO Spelling
* Programming Languages
* Version Control
** TODO Magit
** TODO Diff-HL
* Project Management
* Utilities
** TODO Helpful
** TODO Which Key
** TODO Dired
* Custom Functions
