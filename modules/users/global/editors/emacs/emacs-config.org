#+property: header-args :results silent
#+STARTUP: content

* Info
** Key Bindings
*** Global
| Prefix | Name                    |
|--------+-------------------------|
| C-c a  | avy char                |
| C-c b  | beframe                 |
| C-c c  | chatgpt-send            |
| C-c d  | >consult                |
| C-c f  | format-all              |
| C-c g  | magit                   |
| C-c h  |                         |
| C-c i  |                         |
| C-c j  |                         |
| C-c k  |                         |
| C-c l  |                         |
| C-c n  |                         |
| C-c o  | >completion             |
| C-c p  | >eat-programs           |
| C-c q  |                         |
| C-c s  | git time machine        |
| C-c t  | >transparency           |
| C-c u  | meow-unviersal-argument |
| C-c v  | single window toggle    |
| C-c w  |                         |
| C-c x  |                         |
| C-c y  |                         |
| C-c z  |                         |
*** Local
**** Prog mode
| Prefix | Name      |
|--------+-----------|
| C-c e  | >eglot    |
| C-c m  | >compile  |
| C-c r  | >quickrun |
** Magit ediff
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq ediff-split-window-function 'split-window-horizontally)
(defun 4lc/ediff-setup-windows-advice (buffer-a buffer-b buffer-c control-buffer)
  (select-window (4lc/get-window-with-highest-counter)))
(advice-add 'ediff-setup-windows :before #'4lc/ediff-setup-windows-advice)
** Investigate packages
** Consult eglot
https://github.com/mohkale/consult-eglot
** Hyperbole
** Emacs everywhere
Doesn't work with wayland: https://github.com/tecosaur/emacs-everywhere/issues/50

* Initialisation
This section contains basic configurations for Emacs to tidy up the interface and set some defaults for the inbuilt modules that don't fit into other categories.
** Byte compile warnings
#+begin_src emacs-lisp :tangle yes
  (setq native-comp-async-report-warnings-errors nil)
#+end_src
** Lexical Binding
#+begin_src emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+end_src
** Truncate Lines
#+begin_src emacs-lisp :tangle yes
  (setopt truncate-partial-width-windows t)
#+end_src
** Fix Emacs home
#+begin_src emacs-lisp :tangle yes
 (setq user-emacs-directory (file-truename "~/.config/emacs/"))
#+end_src
** Disable package downloads
Remove elpa from the package archives so that no packages will be automatically downloaded. All packages will be installed using the nix package manager.

#+begin_src emacs-lisp :tangle yes
  (setq package-archives nil)
#+end_src

** Cleanup interface
Remove some of the default GUI display components that are typically used with mouse rather than keyboard.

#+begin_src emacs-lisp :tangle yes
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (set-fringe-mode 10)
  (menu-bar-mode -1)
  (setopt inhibit-startup-message t)
#+end_src

** Disabled commands
Emacs has disabled some inbuilt functions by default as a safety measure. Replacing the function that is called prior to running these enables all these commands without further confirmation.

#+begin_src emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+end_src

** Use short answers
Allow use of y/n instead of yes/no for interactive command confirmations.

#+begin_src emacs-lisp :tangle yes
  (setq use-short-answers t)
#+end_src

** Clean directories
Tell Emacs not to create lock files as everything being edited is single user so should have no conflicts over files. Use of no-littering to reduce other files being scattered in the file system and keep the Emacs folder clean.

#+begin_src emacs-lisp :tangle yes
  (use-package no-littering :demand t :config (no-littering-theme-backups))
  (setq create-lockfiles nil)
#+end_src

** Buffer auto revert
Revert the buffer to the on disk file contents when they are changed outside of Emacs.

#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
  (setq auto-revert-verbose nil)
#+end_src

** Environment Variable import
#+begin_src emacs-lisp :tangle yes
  (use-package
   exec-path-from-shell
   :config
   (exec-path-from-shell-copy-env "SSH_AGENT_PID")
   (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+end_src

** Indentation
Tabs are evil so they are disabled. Indentation defaults to 2.
Dtrt-indent used to guess indentation used in current file and override local setting.
Inhibit electric indent from re-indenting.
#+begin_src emacs-lisp :tangle yes
  (use-package
   dtrt-indent
   :init (setopt dtrt-indent-global-mode t)
   (defun 4lc/dtrt-indent-after-enable ()
     (when (bound-and-true-p indent-bars-mode)
       (indent-bars-reset)))
   :hook (dtrt-indent-mode . 4lc/dtrt-indent-after-enable))
#+end_src

* Core Utilities
Utilities for Emacs that support further parts of the configuration.
** Direnv
#+begin_src emacs-lisp :tangle yes
  (use-package
   direnv
   :config (setopt direnv-always-show-summary nil)
   :init (direnv-mode))
#+end_src
** GCMH
#+begin_src emacs-lisp :tangle yes
  (use-package gcmh
    :init
    (gcmh-mode 1))
#+end_src

** Transient
#+begin_src emacs-lisp :tangle yes
  (use-package transient)
#+end_src

** Url
#+begin_src emacs-lisp :tangle yes
  (use-package
   url
   :config
   (advice-add 'url-http-create-request :override '4lc/url-http-create-request)
   :init
   (defun 4lc/url-http-create-request ()
     "Create an HTTP request for `url-http-target-url'.
  Use `url-http-referer' as the Referer-header (subject to `url-privacy-level')."
     (let* ((extra-headers)
            (request nil)
            (no-cache
             (cdr-safe (assoc "Pragma" url-http-extra-headers)))
            (using-proxy url-http-proxy)
            (proxy-auth
             (if (or (cdr-safe
                      (assoc
                       "Proxy-Authorization" url-http-extra-headers))
                     (not using-proxy))
                 nil
               (let ((url-basic-auth-storage
                      'url-http-proxy-basic-auth-storage))
                 (url-get-authentication url-http-proxy nil 'any nil))))
            (real-fname (url-filename url-http-target-url))
            (host (url-host url-http-target-url))
            (auth
             (if (cdr-safe
                  (assoc "Authorization" url-http-extra-headers))
                 nil
               (url-get-authentication
                (or (and (boundp 'proxy-info) proxy-info)
                    url-http-target-url)
                nil 'any nil)))
            (ref-url (url-http--encode-string url-http-referer)))
       (if (equal "" real-fname)
           (setq real-fname "/"))
       (setq no-cache (and no-cache (string-match "no-cache" no-cache)))
       (if auth
           (setq auth (concat "Authorization: " auth "\r\n")))
       (if proxy-auth
           (setq proxy-auth
                 (concat "Proxy-Authorization: " proxy-auth "\r\n")))

       ;; Protection against stupid values in the referrer
       (if (and ref-url
                (stringp ref-url)
                (or (string= ref-url "file:nil") (string= ref-url "")))
           (setq ref-url nil))

       ;; url-http-extra-headers contains an assoc-list of
       ;; header/value pairs that we need to put into the request.
       (setq extra-headers
             (mapconcat (lambda (x) (concat (car x) ": " (cdr x)))
                        url-http-extra-headers
                        "\r\n"))
       (if (not (equal extra-headers ""))
           (setq extra-headers (concat extra-headers "\r\n")))

       ;; This was done with a call to `format'.  Concatenating parts has
       ;; the advantage of keeping the parts of each header together and
       ;; allows us to elide null lines directly, at the cost of making
       ;; the layout less clear.
       (setq request
             (concat
              ;; The request
              (or url-http-method "GET") " "
              (url-http--encode-string
               (if (and using-proxy
                        ;; Bug#35969.
                        (not
                         (equal
                          "https" (url-type url-http-target-url))))
                   (let ((url (copy-sequence url-http-target-url)))
                     (setf (url-host url)
                           (puny-encode-domain (url-host url)))
                     (url-recreate-url url))
                 real-fname))
              " HTTP/" url-http-version "\r\n"
              ;; Version of MIME we speak
              "MIME-Version: 1.0\r\n"
              ;; (maybe) Try to keep the connection open
              "Connection: "
              (if (or using-proxy (not url-http-attempt-keepalives))
                  "close"
                "keep-alive")
              "\r\n"
              ;; HTTP extensions we support
              (if url-extensions-header
                  (format "Extension: %s\r\n" url-extensions-header))
              ;; Who we want to talk to
              (unless (assoc "Host" url-http-extra-headers)
                (if (/=
                     (url-port url-http-target-url)
                     (url-scheme-get-property
                      (url-type url-http-target-url) 'default-port))
                    (format "Host: %s:%d\r\n"
                            (url-http--encode-string
                             (puny-encode-domain host))
                            (url-port url-http-target-url))
                  (format "Host: %s\r\n"
                          (url-http--encode-string
                           (puny-encode-domain host)))))
              ;; Who its from
              (if url-personal-mail-address
                  (concat "From: " url-personal-mail-address "\r\n"))
              ;; Encodings we understand
              (if (or url-mime-encoding-string
                      ;; MS-Windows loads zlib dynamically, so recheck
                      ;; in case they made it available since
                      ;; initialization in url-vars.el.
                      (and (eq 'system-type 'windows-nt)
                           (fboundp 'zlib-available-p)
                           (zlib-available-p)
                           (setq url-mime-encoding-string "gzip")))
                  (concat
                   "Accept-encoding: " url-mime-encoding-string "\r\n"))
              (if url-mime-charset-string
                  (concat
                   "Accept-charset: "
                   (url-http--encode-string
                    url-mime-charset-string)
                   "\r\n"))
              ;; Languages we understand
              (if url-mime-language-string
                  (concat
                   "Accept-language: " url-mime-language-string "\r\n"))
              ;; Types we understand
              "Accept: " (or url-mime-accept-string "*/*") "\r\n"
              ;; User agent
              (url-http-user-agent-string)
              ;; Proxy Authorization
              proxy-auth
              ;; Authorization
              auth
              ;; Cookies
              (when (url-use-cookies url-http-target-url)
                (url-http--encode-string
                 (url-cookie-generate-header-lines
                  host
                  real-fname
                  (equal "https" (url-type url-http-target-url)))))
              ;; If-modified-since
              (if (and (not no-cache)
                       (member url-http-method '("GET" nil)))
                  (let ((tm (url-is-cached url-http-target-url)))
                    (if tm
                        (concat
                         "If-modified-since: "
                         (url-get-normalized-date tm)
                         "\r\n"))))
              ;; Whence we came
              (if ref-url
                  (concat "Referer: " ref-url "\r\n"))
              extra-headers
              ;; Length of data
              (if url-http-data
                  (concat
                   "Content-length: "
                   (number-to-string (length url-http-data))
                   "\r\n"))
              ;; End request
              "\r\n"
              ;; Any data
              url-http-data))
       ;; Bug#23750
       (unless (= (string-bytes request) (length request))
         (error "Multibyte text in HTTP request: %s" request))
       (url-http-debug "Request is: \n%s" request)
       request)))
#+end_src

* Help
** Helpful
#+begin_src emacs-lisp :tangle yes
  (use-package
   helpful
   :commands (helpful-callable helpful-command helpful-key helpful-variable helpful-at-point)
   :bind
   ([remap describe-function] . helpful-callable)
   ([remap describe-command] . helpful-command)
   ([remap describe-variable] . helpful-variable)
   ([remap describe-key] . helpful-key)
   ([remap Info-goto-emacs-command-node] . helpful-function)
   ("C-h M-p" . helpful-at-point))
#+end_src

** Which key
Popup to show available shortcut keys in current mode
#+begin_src emacs-lisp :tangle yes
  (use-package
   which-key
   :demand
   :config
   (which-key-mode)
   (which-key-add-keymap-based-replacements org-mode-map "C-c C-v" "Org babel" "C-c C-x" "Org extra")
   :bind
   (:map
    help-map
    ("C-h" . which-key-C-h-dispatch)
    ("M-w" . which-key-show-top-level)
    ("M-m" . which-key-show-major-mode))
   :custom
   (which-key-show-early-on-C-h t "Press C-h to show commands")
   (which-key-idle-delay 1 "Delay which key normal display")
   (which-key-idle-secondary-delay 0.05 "Quicker which-key subsequest display")
   (which-key-max-description-length (- (/ (frame-width) 2) 1))
   (which-key-show-remaining-keys t))
#+end_src

** GPTel
#+begin_src emacs-lisp :tangle yes
  (use-package
   gptel
   :demand t
   :init
   (defun 4lc/set-gptel-directive (&optional language)
     "Set the gptel directive to respond as code for the
  current buffers language "
     (let ((lang (language-id-buffer)))
       (when lang
         (unless (assoc (intern (downcase lang)) gptel-directives)
           (let ((prompt (format "Respond with %s code only. No quotes." lang)))
             (setq-local gptel-directives
                         (append
                          `((,(intern (downcase lang)) . ,prompt)) gptel-directives))
             (setq-local gptel--system-message prompt))))))

   (defun 4lc/gptel-y-n (f &rest args)
     "Add confirmation to prevent accidental sends"
     (when (yes-or-no-p "Are you sure you want to send to AI?")
       (apply f args)))
   (advice-add 'gptel-curl-get-response :around #'4lc/gptel-y-n)
   (advice-add 'gptel--url-get-response :around #'4lc/gptel-y-n)
   :config (setopt gptel-model "gpt-4o")
   :commands (gptel)
   :bind ("C-c c" . gptel-send)
   :hook ((prog-mode yaml-mode) . 4lc/set-gptel-directive))
#+end_src

** Codeium
#+begin_src emacs-lisp :tangle yes
  (use-package
   codeium
   :init
   (defalias
     'cape-codeium
     (cape-capf-interactive #'codeium-completion-at-point))
   :config
   (setq codeium/metadata/api_key
         "7cf3b1f3-b8b5-4de1-bc7e-3b95904604bf")
   :autoload codeium-completion-at-point
   :bind ("C-c o c" . cape-codeium))
#+end_src
* Window  Management
** Window visited order
Store a window parameter in non side windows. This is intended to be used to order windows and find the last visited window for display buffer functions.
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/increment-and-store-window-count (frame)
    "Increment the window counter and store it as a window parameter."
    (let ((selected-win (selected-window)))
      (when (and selected-win
                 (not (window-parameter selected-win 'window-side))
                 (not (window-minibuffer-p selected-win)))
        (with-selected-frame (window-frame selected-win)
          (let ((current-count (or (frame-parameter nil '4lc/window-counter) 0)))
            (setq current-count (+ 1 current-count))
            (set-frame-parameter nil '4lc/window-counter current-count)
            (set-window-parameter selected-win '4lc/window-counter current-count))))))

  (add-hook 'window-selection-change-functions '4lc/increment-and-store-window-count)

  (defun 4lc/get-window-counter ()
    "Get the window counter value from the selected window's parameter."
    (let ((selected-win (selected-window)))
      (when selected-win
        (window-parameter selected-win '4lc/window-counter))))

  (defun 4lc/get-window-with-highest-counter ()
 "Get the window in the current frame with the highest window counter."
    (let ((current-frame (selected-frame))
          (windows (window-list)))
      (cl-reduce
       (lambda (win1 win2)
         (let ((counter1 (window-parameter win1 '4lc/window-counter))
               (counter2 (window-parameter win2 '4lc/window-counter)))
           (if (and counter1 counter2)
               (if (> counter1 counter2)
                   win1
                 win2)
             (if counter1
                 win1
               win2))))
       windows
       :initial-value nil)))
#+end_src
** Window resize
Functions to directly set the height and width of windows as either percentage of frame width or character width.
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/get-window-delta (size)
    (- size (window-height)))

  (defun 4lc/get-window-width-delta (size)
    (- size (window-width)))

  (defun 4lc/set-window-width (val &optional window)
    (window-resize window (- val (window-width window)) t))

  (defun 4lc/window-resize-width (val &optional window)
    (if (< val 1)
        (4lc/set-window-width (truncate (* val (frame-width))) window)
      (4lc/set-window-width val window)))

  (defun 4lc/side-window-width (window &optional side)
    (let ((side (or side (window-parameter window 'window-side))))
      (pcase side
        ('left 4lc/left-side-window-width)
        ('right 4lc/right-side-window-width))))

  (defun 4lc/set-window-height (val &optional window)
    (window-resize window (- val (window-height window))))

  (defun 4lc/window-resize-height (val &optional window)
    (if (< val 1)
        (4lc/set-window-height (truncate (* val (frame-height))) window)
      (4lc/set-window-height val window)))

  (defun 4lc/side-window-height (window &optional side)
    (let ((side (or side (window-parameter window 'window-side))))
      (pcase side
        ('top 4lc/top-side-window-height)
        ('bottom 4lc/bottom-side-window-height))))
#+end_src
** Display Buffer rules
#+begin_src emacs-lisp :tangle yes
  (defun display-buffer-maybe-most-recent-window (buffer alist)
    (unless (cdr (assq 'inhibit-same-window alist))
      (window--display-buffer
       buffer (4lc/get-window-with-highest-counter) 'reuse
       alist)))

  (defun display-buffer-split-current-window (buffer alist)
    (when (window-splittable-p (selected-window) t)
      (window--display-buffer buffer (split-window-sensibly) 'window
                              alist)))

  (defun 4lc/display-buffer-alist-right (title &optional slot)
    (let ((selected-slot
           (if slot
               slot
             0)))
      (add-to-list
       'display-buffer-alist
       `(,title
         (display-buffer-in-side-window)
         (window-width . 0.3)
         (side . right)
         (slot . ,selected-slot)
         (window-parameters . ((no-delete-other-windows . t)))))))

  (defun 4lc/display-buffer-alist-bottom (title)
    (add-to-list
     'display-buffer-alist
     `(,title
       (display-buffer-in-side-window)
       (window-height . 0.3)
       (side . bottom)
       (slot . 0)
       (window-parameters . ((no-delete-other-windows . t))))))

  (defun 4lc/display-buffer-alist-top (title)
      (add-to-list
       'display-buffer-alist
       `(,title
         (display-buffer-in-side-window)
         (window-height . 0.3)
         (side . top)
         (slot . 0)
         (window-parameters . ((no-delete-other-windows . t))))))

  (defun 4lc/display-buffer-derived-mode-p (mode)
    `(lambda (buffer-name action)
       (with-current-buffer buffer-name
         (derived-mode-p ',mode))))

  (use-package
   window
   :init
   (setq display-buffer-base-action
         '((display-buffer--maybe-same-window
            display-buffer-reuse-window
            display-buffer-maybe-most-recent-window
            display-buffer-in-previous-window
            display-buffer-use-some-window
            display-buffer-split-current-window)))
   (setopt switch-to-buffer-obey-display-actions t)
   (let ((buffer-rules
          `(("^\\*.*\\*$" 1)
            "^\\*Woman.*\\*$"
            "^\\*help"
            "^\\*info"
            "^\\*Terraform:"
            "^magit:"
            "^magit-revision"
            "^COMMIT_EDITMSG$"
            "^\\*Embark .*\\*$"
            ,(4lc/display-buffer-derived-mode-p 'dired-mode)
            ("^\\*format-all-errors\\*$" 1)
            "^\\*Org Help\\*$")))
     (-each
      buffer-rules
      (lambda (item)
        (if (and (listp item) (not (eq (car item) 'lambda)))
            (apply #'4lc/display-buffer-alist-right item)
          (4lc/display-buffer-alist-right item)))))
   (let ((buffer-rules
          `("^\\*.*compile.*\\*$"
            "^\\*Backtrace\\*$"
            "^\\*Warnings\\*$"
            "^\\*Messages\\*$"
            "^\\*Org Src"
            "^\\*Occur\\*$"
            "^\\*refs.*$"
            "^\\*Flymake.*\\*$"
            "^\\*Embark.*\\*$"
            "^\\*yaml-pro-edit\\*$")))
     (-each
      buffer-rules
      (lambda (item) (4lc/display-buffer-alist-top item))))
   (let ((exceptions
          `("^\\*scratch.*\\*$"
            "^\\*GNU Emacs\\*$"
            "^\\*Kubel:.*\\*$"
            "^\\*fish.*\\*$"
            "^\\*.**eat\\*$"
            "^\\*.**eww*\\*$"
            "[Ee]diff")))
     (-each
      exceptions
      (lambda (item) (add-to-list 'display-buffer-alist `(,item))))))
#+end_src
** Ace window
#+begin_src emacs-lisp :tangle yes
  (use-package ace-window :bind ("M-o" . ace-window))
#+end_src
** Beframe
#+begin_src emacs-lisp :tangle yes
  (use-package
   beframe
   :after consult
   :init
   (beframe-mode 1)
   (defvar consult-buffer-sources)
   (declare-function consult--buffer-state "consult")

   (defface beframe-buffer '((t :inherit font-lock-string-face))
     "Face for `consult' framed buffers.")

   (defun my-beframe-buffer-names-sorted (&optional frame)
     "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
    With optional argument FRAME, return the list of buffers of FRAME."
     (beframe-buffer-names
      frame
      :sort #'beframe-buffer-sort-visibility))

   (defvar beframe-consult-source
     `(:name
       "Frame-specific buffers (current frame)"
       :narrow ?F
       :category buffer
       :face beframe-buffer
       :history beframe-history
       :items ,#'my-beframe-buffer-names-sorted
       :action ,#'switch-to-buffer
       :state ,#'consult--buffer-state))

   (add-to-list 'consult-buffer-sources 'beframe-consult-source)
   :bind-keymap (("C-c b" . beframe-prefix-map)))
#+end_src
** Max window
#+begin_src emacs-lisp :tangle yes
  (defun 4lc/toggle-single-window ()
    (interactive)
    (if (equal (selected-window) (next-window))
        (when (frame-parameter
               (selected-frame) 'toggle-window-configuration)
          (progn
            (set-window-configuration
             (frame-parameter
              (selected-frame) 'toggle-window-configuration))
            (set-frame-parameter
             (selected-frame) 'toggle-window-configuration nil)))
      (progn
        (set-frame-parameter
         (selected-frame)
         'toggle-window-configuration
         (current-window-configuration))
        (when (window-parameter (selected-window) 'window-side)
          (select-window
           (display-buffer-maybe-most-recent-window
            (current-buffer) nil)))
        (while (not (equal (selected-window) (next-window)))
          (delete-window (next-window))))))

  (global-set-key (kbd "C-c v") '4lc/toggle-single-window)
#+end_src
* Visual
** Theme
Setup the main theme and fonts used within this emacs configuration.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'default-frame-alist '(font . "FiraCode Nerd Font-10"))
  (setopt nerd-icons-font-family "FiraCode Nerd Font")

  (use-package
   emacs
   :init (load-theme 'modus-operandi t)
   :bind ("<f5>" . modus-themes-toggle))
#+end_src

** Alert notification
When Emacs reports an exception the default action is to play a bell sound. This replaces the sound with a double flash on the mode-line background.

#+begin_src emacs-lisp :tangle yes
  (defun double-flash-modeline ()
    (let ((flash-sec (/ 1.0 20)))
      (invert-face 'mode-line)
      (run-with-timer flash-sec nil #'invert-face 'mode-line)
      (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
      (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
  (setq
   visible-bell nil
   ring-bell-function 'double-flash-modeline)
#+end_src

** Transparency
Set default transparency of frames and creation of hydra function for adjusting alpha.

#+begin_src emacs-lisp :tangle yes
  (defun set-frame-alpha (value)
    (set-frame-parameter nil 'alpha-background value))

  (defun get-frame-alpha ()
    (frame-parameter nil 'alpha-background))

  (defun change-frame-alpha-by (value)
    (let ((newAlpha (+ value (get-frame-alpha))))
      (if (> newAlpha (get-frame-alpha))
          (if (> newAlpha 100)
              (set-frame-alpha 100)
            (set-frame-alpha newAlpha))
        (if (< newAlpha 0)
            (set-frame-alpha 0)
          (set-frame-alpha newAlpha)))))
  (set-frame-alpha 100)
  (add-to-list 'default-frame-alist '(alpha-background . 100))

  (transient-define-suffix
   clover--transient-transparency-increase-frame-alpha
   ()
   :key "i"
   :description
   "Increase"
   (interactive)
   (change-frame-alpha-by 1))
  (transient-define-suffix
  clover--transient-transparency-decrease-frame-alpha
   ()
   :key "d"
   :description
   "Decrease"
   (interactive)
   (change-frame-alpha-by -1))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-low
   ()
   :key "l"
   :description
   "Low"
   (interactive)
   (set-frame-alpha 0))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-high
   ()
   :key "h"
   :description
   "High"
   (interactive)
   (set-frame-alpha 100))
  (transient-define-suffix
   clover--transient-transparency-frame-alpha-reset
   ()
   :key "r"
   :description
   "r"
   (interactive)
   (set-frame-alpha 85))

  (transient-define-prefix
   ct-transparency ()
   :transient-suffix 'transient--do-stay
   :transient-non-suffix 'transient--do-exit
   [(clover--transient-transparency-increase-frame-alpha)
    (clover--transient-transparency-decrease-frame-alpha)
    (clover--transient-transparency-frame-alpha-low)
    (clover--transient-transparency-frame-alpha-high)
    (clover--transient-transparency-frame-alpha-reset)])
  (bind-key "C-c t" 'ct-transparency)
#+end_src

** Nerd Icons
For completions windows
#+begin_src emacs-lisp :tangle yes
  (use-package
   nerd-icons-completion
   :after marginalia
   :config
   (nerd-icons-completion-mode)
   (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

* Project Management
** Project
#+begin_src emacs-lisp :tangle yes
  (use-package
   project
   :config (project-forget-projects-under "~/Next-Technology" t)
   :bind ("C-x p t" . eat-project))
#+end_src
** Version control
Using Magit as the git porcelain. Is configured to use the same window rather than open a new one for all operations possible. As some operations such as commit open the diff window as well, those buffers open in a seperate window.

#+begin_src emacs-lisp :tangle yes
  (use-package
   magit
   :demand t
   :config
   (defun 4lc/magit-post-clone-hook ()
     "Delete local branches after cloning if the repository is a bare clone."
     (unless (file-exists-p (expand-file-name ".git" default-directory))
       (cd default-directory)
       (shell-command
        "git for-each-ref --format='%\(refname:short\)' refs/heads | grep -v 'master\\|main' | xargs -n 1 git branch -D")))
   (add-hook 'magit-post-clone-hook #'4lc/magit-post-clone-hook)
   (setq magit-display-buffer-function #'display-buffer)
   (setq-default magit-clone-set-remote.pushDefault t)
   (advice-add
    'magit-worktree-delete
    :after
    (lambda (&optional WORKTREE) (project-forget-zombie-projects)))
   :bind (("C-c g" . 4lc/magit-status) ("C-x p m" . magit-project-status)))
#+end_src

Easy look through files git history
#+begin_src emacs-lisp :tangle yes
  (use-package git-timemachine
    :bind ("C-c s" . git-timemachine))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun magit-status-next ()
    (interactive)
    (let ((project-root "~/Next-Technology/"))
      (magit-status
       (completing-read
        "Project: "
        (mapcan
         (lambda (d)
           (directory-files (concat project-root d) t "\\`[^.]"))
         (-filter
          (lambda (d) (file-directory-p (concat project-root d)))
          (directory-files project-root nil "\\`[^.]")))))))

  (defun 4lc/magit-status (arg)
    "Call magit-status, but if called with the prefix operation
  it should call magit-status-next"
    (interactive "P")
    (if (equal arg '(4))
        (progn
          (call-interactively 'magit-status-next)
          (setq current-prefix-arg nil))
      (call-interactively 'magit-status)))
#+end_src
* Navigation
** Avy
#+begin_src emacs-lisp :tangle yes
  (use-package
   avy
   :config (setopt avy-timeout-seconds 0.2)

   (setf
    (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
    (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line
    (alist-get ?l avy-dispatch-alist) 'avy-action-teleport
    (alist-get ?m avy-dispatch-alist) 'avy-action-mark
    (alist-get ?w avy-dispatch-alist) 'avy-action-copy
    (alist-get ?x avy-dispatch-alist) 'avy-action-kill-move
    (alist-get ?y avy-dispatch-alist) 'avy-action-yank
    (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-line
    (alist-get ?z avy-dispatch-alist) 'avy-action-zap-to-char)
   (setopt avy-keys '(?i ?s ?r ?t ?n ?e ?a ?o))
   (-each
    avy-keys
    (lambda (x) (setq avy-dispatch-alist (delq (assoc x avy-dispatch-alist) avy-dispatch-alist))))

   :bind ("C-c a" . avy-goto-char-timer))

  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window (cdr (ring-ref avy-ring 0))))
#+end_src
** Consult
#+begin_src emacs-lisp :tangle yes
  (use-package
   consult
   :init (setopt enable-recursive-minibuffers t)
   (setq
    xref-show-xrefs-function #'consult-xref
    xref-show-definitions-function #'consult-xref)
   :bind
   ( ;; C-c bindings in `mode-specific-map'
    ("C-c M-x" . consult-mode-command)
    ("C-c d h" . consult-history)
    ("C-c d k" . consult-kmacro)
    ("C-c d m" . consult-man)
    ("C-c d i" . consult-info)
    ([remap Info-search] . consult-info)
    ;; C-x bindings in `ctl-x-map'
    ("C-x M-:" . consult-complex-command) ;; orig. repeat-complex-command
    ("C-x b" . consult-buffer) ;; orig. switch-to-buffer
    ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
    ("C-x 5 b" . consult-buffer-other-frame) ;; orig. switch-to-buffer-other-frame
    ("C-x t b" . consult-buffer-other-tab) ;; orig. switch-to-buffer-other-tab
    ("C-x r b" . consult-bookmark) ;; orig. bookmark-jump
    ("C-x p b" . consult-project-buffer) ;; orig. project-switch-to-buffer
    ;; Custom M-# bindings for fast register access
    ("M-#" . consult-register-load)
    ("M-'" . consult-register-store) ;; orig. abbrev-prefix-mark (unrelated)
    ("C-M-#" . consult-register)
    ;; Other custom bindings
    ("M-y" . consult-yank-pop) ;; orig. yank-pop
    ;; M-g bindings in `goto-map'
    ("M-g e" . consult-compile-error)
    ("M-g f" . consult-flymake)
    ("M-g g" . consult-goto-line) ;; orig. goto-line
    ("M-g M-g" . consult-goto-line) ;; orig. goto-line
    ("M-g o" . consult-outline) ;; Alternative: consult-org-heading
    ("M-g m" . consult-mark)
    ("M-g k" . consult-global-mark)
    ("M-g s" . consult-flyspell)
    ("M-g i" . consult-imenu)
    ("M-g I" . consult-imenu-multi)
    ("M-g y" . consult-yasnippet)
    ;; M-s bindings in `search-map'
    ("M-s d" . consult-find) ;; Alternative: consult-fd
    ("M-s g" . consult-grep)
    ("M-s G" . consult-git-grep)
    ("M-s r" . consult-ripgrep)
    ("M-s l" . consult-line)
    ("M-s L" . consult-line-multi)
    ("M-s k" . consult-keep-lines)
    ("M-s u" . consult-focus-lines)
    ;; Isearch integration
    ("M-s e" . consult-isearch-history)
    :map
    isearch-mode-map
    ("M-e" . consult-isearch-history) ;; orig. isearch-edit-string
    ("M-s e" . consult-isearch-history) ;; orig. isearch-edit-string
    ("M-s l" . consult-line) ;; needed by consult-line to detect isearch
    ("M-s L" . consult-line-multi) ;; needed by consult-line to detect isearch
    ;; Minibuffer history
    :map
    minibuffer-local-map
    ("M-s" . consult-history) ;; orig. next-matching-history-element
    ("M-r" . consult-history)))
#+end_src
** Embark
#+begin_src emacs-lisp :tangle yes
  (use-package
   embark
   :bind
   (("C-." . embark-act)
    ("C-;" . embark-dwim)
    ("C-h B" . embark-bindings)
    :map
    embark-identifier-map
    ("RET" . xref-find-definitions-other-window))
   :init (setq prefix-help-command #'embark-prefix-help-command))

  (use-package
   embark-consult
   :after (embark consult)
   :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

Which-key for Embark
#+begin_src emacs-lisp :tangle yes
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets)
                       "â€¦"
                     "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding) (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator embark-highlight-indicator embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter :around #'embark-hide-which-key-indicator)
#+end_src
** Margnalia
#+begin_src emacs-lisp :tangle yes
  (use-package
   marginalia
   :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
   :init (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp :tangle yes
  (use-package
   orderless
   :config (add-to-list 'completion-styles 'orderless)
   :custom
   (completion-category-defaults nil)
   (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Vertico
#+begin_src emacs-lisp :tangle yes
  (use-package vertico :init (vertico-mode) :bind (:map vertico-map ("M-s" . vertico-suspend)))
#+end_src
* Editing
** Modal Editing
#+begin_src emacs-lisp :tangle yes
  (use-package
   meow
   :init (meow-global-mode 1)
   :config
   (setopt meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
   (setopt meow-use-clipboard t)
   (meow-motion-overwrite-define-key
    '("j" . meow-next) '("k" . meow-prev) '("<escape>" . ignore))
   (meow-leader-define-key
    ;; SPC j/k will run the original command in MOTION state.
    '("j" . "H-j")
    '("k" . "H-k")
    '("u" . meow-universal-argument)
    ;; Use SPC (0-9) for digit arguments.
    '("1" . meow-digit-argument)
    '("2" . meow-digit-argument)
    '("3" . meow-digit-argument)
    '("4" . meow-digit-argument)
    '("5" . meow-digit-argument)
    '("6" . meow-digit-argument)
    '("7" . meow-digit-argument)
    '("8" . meow-digit-argument)
    '("9" . meow-digit-argument)
    '("0" . meow-digit-argument)
    '("/" . meow-keypad-describe-key)
    '("?" . meow-cheatsheet))
   (meow-normal-define-key
    '("0" . meow-expand-0)
    '("9" . meow-expand-9)
    '("8" . meow-expand-8)
    '("7" . meow-expand-7)
    '("6" . meow-expand-6)
    '("5" . meow-expand-5)
    '("4" . meow-expand-4)
    '("3" . meow-expand-3)
    '("2" . meow-expand-2)
    '("1" . meow-expand-1)
    '("-" . negative-argument)
    '(";" . meow-reverse)
    '("," . meow-inner-of-thing)
    '("." . meow-bounds-of-thing)
    '("[" . meow-beginning-of-thing)
    '("]" . meow-end-of-thing)
    '("a" . meow-append)
    '("A" . meow-open-below)
    '("b" . meow-back-word)
    '("B" . meow-back-symbol)
    '("c" . meow-change)
    '("d" . meow-delete)
    '("D" . meow-backward-delete)
    '("e" . meow-next-word)
    '("E" . meow-next-symbol)
    '("f" . meow-find)
    '("g" . meow-cancel-selection)
    '("G" . meow-grab)
    '("h" . meow-left)
    '("H" . meow-left-expand)
    '("i" . meow-insert)
    '("I" . meow-open-above)
    '("j" . meow-next)
    '("J" . meow-next-expand)
    '("k" . meow-prev)
    '("K" . meow-prev-expand)
    '("l" . meow-right)
    '("L" . meow-right-expand)
    '("m" . meow-join)
    '("n" . meow-search)
    '("o" . meow-block)
    '("O" . meow-to-block)
    '("p" . meow-yank)
    '("q" . meow-quit)
    '("Q" . meow-goto-line)
    '("r" . meow-replace)
    '("R" . meow-swap-grab)
    '("s" . meow-kill)
    '("t" . meow-till)
    '("u" . meow-undo)
    '("U" . meow-undo-in-selection)
    '("v" . meow-visit)
    '("w" . meow-mark-word)
    '("W" . meow-mark-symbol)
    '("x" . meow-line)
    '("X" . meow-goto-line)
    '("y" . meow-save)
    '("Y" . meow-sync-grab)
    '("z" . meow-pop-selection)
    '("'" . repeat)
    '("<escape>" . ignore)))
#+end_src
** Column Indicator
#+begin_src emacs-lisp :tangle yes
  (use-package
   visual-fill-column
   :config
   (setopt display-fill-column-indicator-column 100)
   (setopt display-fil-lcolumn-indicator-character #xf0689)
   (setopt fill-column 100)
   (setopt visual-fill-column-center-text nil)
   (setopt visual-line-fringe-indicators '(left-curly-arrow nil))
   :hook
   (visual-line-mode . visual-fill-column-mode)
   (text-mode-hook . (lambda () (visual-line-mode t))))
#+end_src
** COMMENT Highlight indentation
Indent bars
#+begin_src emacs-lisp :tangle yes
  (use-package
    indent-bars
    :config
    (setopt indent-bars-pattern ".")
    (setopt indent-bars-width-frac 0.1)
    (setopt indent-bars-highlight-current-depth '(:pattern "." :width 0.40))
    (setopt indent-bars-treesit-support t)
    (setopt indent-bars-no-descend-string t)
    (setopt indent-bars-spacing-override nil)
    :hook ((prog-mode yaml-ts-mode) . indent-bars-mode))
#+end_src

** Line numbers
#+begin_src emacs-lisp :tangle yes
  (use-package simple
    :init
    (setopt display-line-numbers-type 'relative)
    :hook
    (prog-mode . display-line-numbers-mode)
    (yaml-mode . display-line-numbers-mode))
#+end_src
** Macros
#+begin_src emacs-lisp :tangle yes
  (defalias 'convert-devops-yaml-parameter-to-full
     (kmacro "a i - SPC n a m e : <escape> s : <return> <backspace> <return> i SPC SPC t y p e : SPC s t r i n g <return> d e f a u l t : SPC <escape> n a"))
#+end_src
** Org mode
#+begin_src emacs-lisp :tangle yes
  (use-package
   org
   :init
   (defun 4lc/org-babel-add-language (lang)
     (org-babel-do-load-languages
      'org-babel-load-languages
      (add-to-list 'org-babel-load-languages `(,lang . t))))
   (defun 4lc/org-src-lang-override (mode)
     (let ((m (cdr (assoc mode major-mode-remap-alist))))
       (if m
           m
         mode)))
   (advice-add
    #'org-src-get-lang-mode
    :filter-return #'4lc/org-src-lang-override)
   :config
   (setopt org-src-window-setup 'plain)
   (setopt org-startup-indented t)
   (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-delimiters :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Replace region
#+begin_src emacs-lisp :tangle yes
  (delete-selection-mode t)

  (defun 4lc/yank-replace (&optional ARG)
    (if (and (region-active-p) (bound-and-true-p delete-selection-mode))
        (delete-active-region)))

  (advice-add 'yank :before #'4lc/yank-replace)
#+end_src
** Spelling
#+begin_src emacs-lisp :tangle yes
  (use-package
   flyspell
   :config
   (setopt ispell-list-command "--list")
   (setopt ispell-program-name "aspell")
   :bind (:map flyspell-mode-map ("C-." . nil))
   :init
   (defun flyspell-on-for-buffer-type ()
     "Enable Flyspell appropriately for the major mode of the current buffer.  Uses `flyspell-prog-mode' for modes derived from `prog-mode', so only strings and comments get checked.  All other buffers get `flyspell-mode' to check all text.  If flyspell is already enabled, does nothing."
     (interactive)
     (if (not (symbol-value flyspell-mode)) ; if not already on
         (progn
           (if (derived-mode-p 'prog-mode)
               (progn
                 (message "Flyspell on (code)")
                 (flyspell-prog-mode))
             ;; else
             (progn
               (message "Flyspell on (text)")
               (flyspell-mode 1)))
           ;; I tried putting (flyspell-buffer) here but it didn't seem to work
           )))
   (defun flyspell-toggle ()
     "Turn Flyspell on if it is off, or off if it is on.  When turning on, it uses `flyspell-on-for-buffer-type' so code-vs-text is handled appropriately."
     (interactive)
     (if (symbol-value flyspell-mode)
         (progn ; flyspell is on, turn it off
           (message "Flyspell off")
           (flyspell-mode -1))
       ; else - flyspell is off, turn it on
       (flyspell-on-for-buffer-type)))
   :hook ((find-file prog-mode text-mode) . flyspell-on-for-buffer-type))
#+end_src
** Trailing white-space
#+begin_src emacs-lisp :tangle yes
  (use-package
   whitespace
   :config
   (setopt
    whitespace-style
    '(face trailing empty missing-newline-at-eof))
   :hook (prog-mode . whitespace-mode)
   (whitespace-mode
    .
    (lambda ()
      (if whitespace-mode
          (add-hook 'before-save-hook 'whitespace-cleanup nil 'local)
        (remove-hook 'before-save-hook 'whitespace-cleanup 'local)))))
#+end_src

* System
** Dired
- Change dired listing mode to not show full details by default.
- Change listing options to hide . & .. and group directories first.
- Add key-bind for creating new files.
#+begin_src emacs-lisp :tangle yes
  (use-package
   dired
   :config
   (setopt dired-listing-switches "-Alh --group-directories-first")
   (setopt dired-hide-details-hide-symlink-targets nil)
 :bind (:map dired-mode-map ("C-+" . dired-create-empty-file))
   :hook (dired-mode . dired-hide-details-mode))
#+end_src
** Kubernetes
#+begin_src emacs-lisp :tangle yes
  (use-package
   kubel
   :commands kubel
   :config
   (defun kubel-delete-resource-confirmation ()
     (interactive)
     (y-or-n-p "Are you sure you want to delete resource?"))
   (advice-add
    'kubel-delete-resource
    :before-while #'kubel-delete-resource-confirmation)

   (defun kubel-quick-edit ()
     "Quickly edit any resource."
     (interactive)
     (kubel--describe-resource
      (completing-read
       "Select resource: " (kubel--kubernetes-resources-list)))))
#+end_src
** Eat
#+begin_src emacs-lisp :tangle yes
  (use-package
   eat
   :init
  (defmacro 4lc/gen-eat (name)
    `(defun ,(intern (format "4lc/eat-%s" name)) ()
       (interactive)
       (let ((eat-buffer-name ,(format "*%s*" name))
             (eat-kill-buffer-on-exit t))
         (eat ,(prin1-to-string name)))))
   (-each
    '(btop k9s fish bash zsh)
    (lambda (name) (eval `(4lc/gen-eat ,name))))
   :bind
   (("C-c p b" . 4lc/eat-btop)
    ("C-c p k" . 4lc/eat-k9s)
    ("C-c p f" . 4lc/eat-fish)
    ("C-c p s" . 4lc/eat-bash)))
#+end_src
* Programming
** Compilation
#+begin_src emacs-lisp :tangle yes
  (use-package
   compile
   :init
   (defun compile-comint ()
     (interactive)
     (compile (eval compile-command) t))
   :config (setopt save-some-buffers-default-predicate #'save-some-buffers-root)
   :bind
   (:map
    prog-mode-map
    ("C-c m c" . compile)
    ("C-c m r" . recompile)
    ("C-c m i" . compile-comint)))
#+end_src
** Completion
#+begin_src emacs-lisp :tangle yes
  (use-package
   corfu
   :init
   (setopt global-corfu-mode t)
   (defun corfu-move-to-minibuffer ()
     (interactive)
     (pcase completion-in-region--data
       (`(,beg ,end ,table ,pred ,extras)
        (let ((completion-extra-properties extras)
              completion-cycle-threshold
              completion-cycling)
          (consult-completion-in-region beg end table pred)))))
   (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)
   :config
   (setopt corfu-auto t)
   (setopt corfu-quit-no-match t)
   (setopt corfu-popupinfo-mode t)
   (setopt corfu-popupinfo-delay '(0.5 . 0.5))
   (defun corfu-enable-in-minibuffer ()
     "Enable Corfu in the minibuffer if `completion-at-point' is bound."
     (when (where-is-internal #'completion-at-point
                              (list (current-local-map)))
       (setq-local corfu-auto t) ;; Enable/disable auto completion
       (setq-local
        corfu-echo-delay nil ;; Disable automatic echo and popup
        corfu-popupinfo-delay nil)
       (corfu-mode 1)))
   :hook (minibuffer-setup . corfu-enable-in-minibuffer)
   :bind (:map corfu-map ("M-m" . corfu-move-to-minibuffer)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package
   cape
   :bind
   ("C-c o p" . completion-at-point)
   ("C-c o f" . cape-file)
   ("C-c o e" . cape-emoji)
   ("C-c o k" . cape-keyword))

  (use-package
   yasnippet-capf
   :ensure t
   :after cape
   :bind ("C-c o y" . yasnippet-capf))
#+end_src
** Eglot breadcrumbs
#+begin_src emacs-lisp :tangle yes
  (use-package breadcrumb :init (breadcrumb-mode 1))
#+end_src
** Format all
#+begin_src emacs-lisp :tangle yes
  (use-package
   format-all
   :ensure t
   :init
   (defmacro format-all-update-formatter (langid formatter)
     `(setq-default format-all-formatters
                    (cons
                     '(,langid ,formatter)
                     (assoc-delete-all ,langid format-all-formatters))))
   :commands (format-all-mode define-format-all-formatter)
   :bind
   (:map
    prog-mode-map
    ("C-c f f" . format-all-region-or-buffer)
    ("C-c f a" . 4lc/ask-and-store-format-option-for-current-file)
    ("C-c f p" . 4lc/ask-and-store-format-option-for-current-file)
    ("C-c f c" . 4lc/clear-project-format-answer)
    ("C-c f k" . 4lc/clear-file-format-answer))
   :hook (prog-mode . format-all-mode) (yaml-ts-mode . format-all-mode))
#+end_src

Format all modification to  ask for projects and files if should format.

#+begin_src emacs-lisp :tangle yes
  (defvar 4lc/file-format-answers (make-hash-table :test 'equal)
    "Hash table to store user answers about formatting individual files.")

  (defvar 4lc/project-format-answers (make-hash-table :test 'equal)
    "Hash table to store user answers about formatting files in projects.")

  (defvar 4lc/format-file
    (expand-file-name "format-answers.el" user-emacs-directory)
    "File path to store format answers.")

  (defconst 4lc/no-format '4lc/no-format
    "Marker value indicating that formatting is not desired.")

  (defun 4lc/load-format-answers ()
    "Load format answers from disk, cleaning up any zombie entries."
    (when (file-exists-p 4lc/format-file)
      (with-temp-buffer
        (insert-file-contents 4lc/format-file)
        (let ((data (read (current-buffer))))
          (setq 4lc/file-format-answers (car data))
          (setq 4lc/project-format-answers (cdr data))
          (4lc/clean-format-answers)))))

  (defun 4lc/save-format-answers ()
    "Save format answers to disk."
    (with-temp-file 4lc/format-file
      (prin1 (cons 4lc/file-format-answers 4lc/project-format-answers)
             (current-buffer))))

  (defun 4lc/clean-format-answers ()
    "Clean up zombie entries in format answers."
    (maphash
     (lambda (key _)
       (unless (file-exists-p key)
         (remhash key 4lc/file-format-answers)))
     4lc/file-format-answers)
    (maphash
     (lambda (key _)
       (unless (file-exists-p key)
         (remhash key 4lc/project-format-answers)))
     4lc/project-format-answers))

  (defun 4lc/project-root ()
    "Get the root directory of the current project using project.el."
    (when-let ((project (project-current)))
      (expand-file-name (car (project-roots project)))))

  (defun 4lc/ask-to-format (orig-fun &rest args)
    "Ask the user if they want to format the current buffer before saving."
    (let ((file (buffer-file-name))
          (project (4lc/project-root)))
      (cond
       ;; Case: file has saved answer
       ((and file (gethash file 4lc/file-format-answers))
        (when (eq (gethash file 4lc/file-format-answers) t)
          (apply orig-fun args)))
       ;; Case: file is part of a project and project has saved answer
       ((and project (gethash project 4lc/project-format-answers))
        (when (eq (gethash project 4lc/project-format-answers) t)
          (apply orig-fun args)))
       ;; Case: file is part of a project and project doesn't have saved answer
       ((and project (not (gethash project 4lc/project-format-answers)))
        (let ((answer
               (y-or-n-p
                (format "Do you want to format buffers in project %s? "
                        project))))
          (puthash
           project (or answer 4lc/no-format) 4lc/project-format-answers)
          (4lc/save-format-answers)
          (when answer
            (apply orig-fun args))))
       ;; Case: file is not part of a project
       (file
        (let ((answer
               (y-or-n-p
                (format "Do you want to format buffer %s? " file))))
          (puthash
           file (or answer 4lc/no-format) 4lc/file-format-answers)
          (4lc/save-format-answers)
          (when answer
            (apply orig-fun args))))
       ;; Default case: format-all
       (t
        (apply orig-fun args)))))

  (advice-add 'format-all--buffer-from-hook :around #'4lc/ask-to-format)

  (defun 4lc/clear-file-format-answer ()
    "Clear the format answer for the current file."
    (interactive)
    (let ((file (buffer-file-name)))
      (when file
        (remhash file 4lc/file-format-answers)
        (4lc/save-format-answers)
        (message "Cleared format answer for file: %s" file))))

  (defun 4lc/clear-project-format-answer ()
    "Clear the format answer for the current project."
    (interactive)
    (let ((project (4lc/project-root)))
      (when project
        (remhash project 4lc/project-format-answers)
        (4lc/save-format-answers)
        (message "Cleared format answer for project: %s" project))))

  (defun 4lc/ask-and-store-format-option-for-current-file ()
    "Ask the user if they want to format the current buffer's file and store the answer."
    (interactive)
    (let ((file (buffer-file-name))
          (no-format-marker '4lc/no-format))
      (if file
          (let ((answer (y-or-n-p (format "Do you want to format buffer %s? " file))))
            (puthash file (if answer t no-format-marker) 4lc/file-format-answers)
            (4lc/save-format-answers)
            (message "Saved format answer for file: %s" file))
        (message "Current buffer is not associated with a file."))))

  (4lc/load-format-answers)
#+end_src
** Language ID
#+begin_src emacs-lisp :tangle yes
  (use-package
   language-id
   :config
   (setopt
    language-id--definitions
    (append
     '(("Nix" nix-ts-mode) ("nim" nim-mode)) language-id--definitions)))
#+end_src
** LSP
Configuration for LSP support in prog-mode and yaml-ts-mode. Using Emacs inbuilt mode Eglot.
Config options to reduce the logging and improve the performance.
#+begin_src emacs-lisp :tangle yes
  (use-package
   eglot
   :hook ((prog-mode yaml-ts-mode) . eglot-ensure)
   :bind
   (:map
    eglot-mode-map
    ("C-c e r" . eglot-rename)
    ("C-c e f" . eglot-format-buffer)
    ("C-c e a" . eglot-code-actions)
    ("C-c e o" . eglot-code-action-organize-imports)
    ("C-c e i" . eglot-code-action-inline)
    ("C-c e x" . eglot-code-action-extract)
    ("C-c e w" . eglot-code-action-rewrite)
    ("C-c e q" . eglot-code-action-quickfix)
    ("C-c e h" . eldoc))
   :config
   (fset #'jsonrpc--log-event #'ignore)
   (setopt eglot-events-buffer-size 0)
   :custom
   (eglot-report-progress nil "Silence Eglot"))
#+end_src
** Snippets
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet :init (yas-global-mode 1))
#+end_src
** Electric Pair Highlighted region only
#+begin_src emacs-lisp :tangle yes
  (use-package
   elec-pair
   :init
   (defun only-if-use-region (func &rest args)
     (if (use-region-p)
         (apply func args)))
   (advice-add
    'electric-pair-post-self-insert-function
    :around 'only-if-use-region)
   (electric-pair-mode t))
#+end_src
** Treesitter
#+begin_src emacs-lisp :tangle yes
  (use-package
   treesit
   :init
   (defun 4lc/treesitter-major-mode-remap ()
     "Remap major modes to their treesitter counterparts if available."
     (interactive)
     ;; Iterate over all loaded packages and find "-ts-mode" ones
     (dolist (mode (apropos-internal "-ts-mode$" 'functionp))
       (let*
           ((ts-mode-name (symbol-name mode)) ; Convert symbol to string
            (normal-mode-name
             (replace-regexp-in-string
              "-ts-mode$" "-mode" ts-mode-name))
            (normal-mode-symbol (intern-soft normal-mode-name)))
         (when (and normal-mode-symbol (fboundp normal-mode-symbol))
           (progn
             (add-to-list
              'major-mode-remap-alist
              (cons normal-mode-symbol mode)))))))

   (defvar 4lc/treesitter-no-auto-mode ()
     "List of Treesitter modes that are not auto-remapped.")

   (defun 4lc/update-treesitter-no-auto-mode-list ()
     "Update `4lc/treesitter-no-auto-mode' with Treesitter modes not in `major-mode-remap-alist'."
     (setq 4lc/treesitter-no-auto-mode nil)
     (let ((ts-modes
            (seq-filter
             (lambda (mode)
               (string-suffix-p "-ts-mode" (symbol-name mode)))
             (apropos-internal "-ts-mode" 'commandp)))
           (remapped-modes (mapcar 'cdr major-mode-remap-alist))
           (auto-modes (mapcar 'cdr auto-mode-alist)))
       (dolist (mode ts-modes)
         (unless (or (memq mode remapped-modes) (memq mode auto-modes))
           (add-to-list '4lc/treesitter-no-auto-mode mode)))))

   (4lc/treesitter-major-mode-remap)
   (4lc/update-treesitter-no-auto-mode-list)

   :config (setopt treesit-font-lock-level 4)
   :custom
   (setopt
    treesit-extra-load-path '("~/.config/emacs/var/tree-sitter")))
#+end_src
** Code running
#+begin_src emacs-lisp :tangle yes
  (use-package quickrun
    :bind (("C-c r" . quickrun)))
#+end_src
* Languages
** Bash
#+begin_src emacs-lisp :tangle yes
  (use-package
   sh-script
   :init
   (define-format-all-formatter 4lc/shfmt
    (:executable "shfmt")
    (:install)
    (:languages "Shell")
    (:features)
    (:format
     (format-all--buffer-easy
      executable
      (when (buffer-file-name)
          (list "-filename" (buffer-file-name))))))
   (add-to-list 'major-mode-remap-alist (cons 'sh-mode 'bash-ts-mode))
   (4lc/org-babel-add-language 'shell)
   :config (setopt sh-basic-offset 2)
   :hook
   (bash-ts-mode
    .
    (lambda ()
      (format-all-update-formatter "Shell" (4lc/shfmt "-i" "4" "-ci")))))
#+end_src
** CMake
#+begin_src emacs-lisp :tangle yes
  (use-package cmake-ts-mode)
#+end_src
** Dockerfile
#+begin_src emacs-lisp :tangle yes
  (use-package dockerfile-ts-mode)
#+end_src
** Emacs Lisp
#+begin_src emacs-lisp :tangle yes
  (use-package
   elisp-mode
   :init
   (define-format-all-formatter
    elisp-autofmt
    (:executable)
    (:install)
    (:languages "Emacs Lisp")
    (:features region)
    (:format
     (format-all--buffer-native
      'elisp-autofmt-mode
      (if region
          (lambda () (elisp-autofmt-region (car region) (cdr region)))
        (lambda () (elisp-autofmt-region (point-min) (point-max)))))))
   (format-all-update-formatter "Emacs Lisp" elisp-autofmt))
#+end_src
** Go
#+begin_src emacs-lisp :tangle yes
  (use-package
   go-ts-mode
   :init (format-all-update-formatter "Go" goimports)
   :mode ("\\.go\\'" . go-ts-mode) ("/go\\.mod\\'" . go-mod-ts-mode)
   :hook
   ((go-ts-mode
     .
     (lambda ()
       (indent-bars-mode -1)
       (setq-local indent-tabs-mode t)
       (setq-local tab-width 8)
       (setq-local indent-bars-spacing 8)
       (setq-local standard-indent 8)
       (dtrt-indent-mode -1)
       (eglot-format-buffer)
       (indent-bars-mode t)))
    (go-mod-ts-mode
     .
     (lambda ()
       (indent-bars-mode -1)
       (setq-local indent-tabs-mode t)
       (setq-local tab-width 8)
       (setq-local indent-bars-spacing 8)
       (setq-local standard-indent 8)
       (dtrt-indent-mode -1)
       (eglot-format-buffer)
       (indent-bars-mode t)))))
#+end_src
** Markdown
#+begin_src emacs-lisp :tangle yes
  (use-package
   markdown-mode
   :defer t)
#+end_src
** Nim
#+begin_src emacs-lisp :tangle yes
  (use-package
   nim-ts-mode
   :init
   (define-format-all-formatter
    nph
    (:executable "nph")
    (:install)
    (:languages "nim")
    (:features)
    (:format (format-all--buffer-easy executable "-")))
   (format-all-update-formatter "nim" nph)
   (setopt nim-ts-mode--font-base-theme (car custom-enabled-themes))
   :defer t
   :config
   (add-to-list
    'eglot-server-programs '(nim-ts-mode . ("nimlangserver"))))
  (defun flymake-diag-region-drop-col (fun buffer line &optional col)
    (message "Running clover flymake diag")
    (apply fun buffer line))

  (advice-add
   'flymake-diag-region
   :around #'flymake-diag-region-drop-col)
  (advice-remove 'flymake-diag-region #'flymake-diag-region-drop-col)
#+end_src

** Nix
  #+begin_src emacs-lisp :tangle yes
    (use-package
     nix-ts-mode
     :defer t
     :init (format-all-update-formatter "Nix" alejandra)
     :mode "\\.nix\\'"
     :config
     (add-to-list 'eglot-server-programs '(nix-ts-mode . ("nixd"))))
#+end_src
** Python
#+begin_src emacs-lisp :tangle yes
  (use-package
   python
   :defer t
   :init
   (4lc/org-babel-add-language 'python)
   (setf (cdr (rassoc 'python-mode auto-mode-alist)) 'python-ts-mode)
   (setf (cdr (rassoc 'python-mode interpreter-mode-alist)) 'python-ts-mode)
   (format-all-update-formatter "Python" black)
   :hook
   (python-ts-mode
    .
    (lambda ()
      (setq-local python-flymake-command '("flake8" "-"))
      (setopt eglot-workspace-configuration '(:python.\analysis (:typeCheckingMode "strict"))))))
#+end_src
** Rust
#+begin_src emacs-lisp :tangle yes
  (use-package rust-ts-mode :mode "\\.rs\\'")
#+end_src
** Terraform
#+begin_src emacs-lisp :tangle yes
  (use-package
   terraform-mode
   :defer t
   :bind ("C-c C-d C-d" . terraform-doc)
   :config (add-to-list 'eglot-server-programs '(terraform-mode . ("terraform-ls" "serve"))))
#+end_src
** Toml
#+begin_src emacs-lisp :tangle yes
  (use-package
   toml-ts-mode
   :init
   (add-to-list
    'major-mode-remap-alist (cons 'conf-toml-mode 'toml-ts-mode)))
#+end_src
** Typescript
#+begin_src emacs-lisp :tangle yes
  (use-package typescript-ts-mode)
#+end_src
** Yaml
#+begin_src emacs-lisp :tangle yes
  (use-package
   yaml-ts-mode
   :init
   (define-format-all-formatter
    yamlfmt
    (:executable "yamlfmt")
    (:install)
    (:languages "YAML")
    (:features)
    (:format
     (if (project-current)
         (format-all--buffer-easy
          executable "-conf"
          (expand-file-name
           (s-concat (project-root (project-current)) ".yamlfmt"))
          "-")
       (format-all--buffer-easy executable "-"))))
   (format-all-update-formatter "YAML" yamlfmt)
   :defer t)

  (use-package
   yaml-pro
   :hook (yaml-ts-mode . yaml-pro-ts-mode)
   :bind
   (:map
    yaml-pro-ts-mode
    ("M-<up>" . yaml-pro-ts-move-subtree-up)
    ("M-<down>" . yaml-pro-ts-move-subtree-down))
   (:repeat-map
    my/yaml-pro/tree-repeat-map
    ("n" . yaml-pro-ts-next-subtree)
    ("p" . yaml-pro-ts-prev-subtree)
    ("u" . yaml-pro-ts-up-level)
    ("d" . yaml-pro-ts-down-level)
    ("m" . yaml-pro-ts-mark-subtree)
    ("k" . yaml-pro-ts-kill-subtree)
    ("a" . yaml-pro-ts-first-sibling)
    ("e" . yaml-pro-ts-last-sibling)
    ("SPC" . my/yaml-pro/set-mark)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package
   restclient
   :hook
   (restclient-mode . restclient-test-mode)
   (restclient-test-mode . flymake-mode))
#+end_src
** Verb
#+begin_src emacs-lisp :tangle yes
  (use-package verb :init (4lc/org-babel-add-language 'verb))
#+end_src
** LISP
#+begin_src emacs-lisp :tangle yes
  (use-package
   sly
   :init (4lc/org-babel-add-language 'lisp)
   :custom (inferior-lisp-program "sbcl"))
#+end_src
** ZIG
#+begin_src emacs-lisp :tangle yes
  (use-package zig-mode
    :mode ("\\.zig\\'" . zig-mode))
#+end_src
